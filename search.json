[{"title":"React19概览","path":"/2025/04/20/19React19/","content":"React 19 于 2024 年底正式发布，带来了诸多令人振奋的新特性，旨在简化开发流程、提升性能，并增强用户体验。作为一名前端开发者，我在第一时间深入研究了这些更新，并在此与大家分享我的见解。 🚀 Actions API：简化异步操作与表单处理React 19 引入了 Actions API，极大地简化了异步状态管理和错误处理。通过 useActionState 和 useOptimistic 等新 Hook，开发者可以更轻松地处理表单提交、乐观更新等场景例如，使用 useActionState 可以简化表单提交的状态管理 123456789const [error, submitAction, isPending] = useActionState( async (prevState, formData) =&gt; &#123; const error = await updateName(formData.get(&quot;name&quot;)); if (error) return error; redirect(&quot;/path&quot;); return null; &#125;, null); 而 useOptimistic 则允许在等待服务器响应的同时立即更新 UI，提升用户体验 🧵 新的 use() Hook：统一异步资源处理React 19 引入了 use() Hook，用于在渲染期间读取异步资源，如 Promise 或 Context。它与 Suspense 深度集成，支持条件调用，简化了异步数据的处理流。例： 123456import &#123; use &#125; from &#x27;react&#x27;;function Comments(&#123; commentsPromise &#125;) &#123; const comments = use(commentsPromise); return comments.map(comment =&gt; &lt;p key=&#123;comment.id&#125;&gt;&#123;comment&#125;&lt;/p&gt;);&#125; 这使得处理异步数据变得更加直观和简。 🧠 React Compiler：自动优化渲染性React 19 引入了 React Compiler，自动优化组件的重新渲染，减少了对 useMemo、useCallback 和 memo 的赖。 例如，之前我们可能会这写： 12345678910111213141516171819import React, &#123; useMemo, useCallback &#125; from &#x27;react&#x27;;function ExpensiveComponent(&#123; data, onItemClick &#125;) &#123; const processedData = useMemo(() =&gt; &#123; return data.map(item =&gt; item * 2); &#125;, [data]); const handleClick = useCallback((item) =&gt; &#123; onItemClick(item); &#125;, [onItemClick]); return ( &lt;ul&gt; &#123;processedData.map(item =&gt; ( &lt;li key=&#123;item&#125; onClick=&#123;() =&gt; handleClick(item)&#125;&gt;&#123;item&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125; 而在 React 19 中，React Compiler 会自动进行这些化： 12345678910111213import React from &#x27;react&#x27;;function ExpensiveComponent(&#123; data, onItemClick &#125;) &#123; const processedData = data.map(item =&gt; item * 2); return ( &lt;ul&gt; &#123;processedData.map(item =&gt; ( &lt;li key=&#123;item&#125; onClick=&#123;() =&gt; onItemClick(item)&#125;&gt;&#123;item&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125; 这大大简化了代码，提高了开发率。 🧩 其他重要更新 Context 简：现在可以直接使用 &lt;Context&gt; 代替 &lt;Context.Provider&gt;，简化了上下文使用。 Ref 回调的清理功：为 ref 回调增加了清理函数支持，允许在组件卸载时自动执行清逻辑。 文档元数据支：引入了原生的文档元数据管理，提升了 SEO 和社交媒体分享体验。 异步脚本和资源预加载支：增强了对异步脚本和资源预加载的支持，优化了页面加性能。 🧪 实际感受在实际项目中应用 React 19 的新特性后，我深刻体会到开发效率的提升和代码的简洁性。例如，使用 useActionState 管理表单状态，使得代码更加清晰易懂；而 React Compiler 的自动优化功能，则让我不再为性能优而烦恼。 React 19 的发布标志着前端开发进入了一的阶段。它不仅简化了开发流程，还提升了应用的性能户体验。作为开发者，我们应积极学习和应用这些新特性，以构建更高效、更现代的 Web 应用。"},{"title":"我最近的生活","path":"/2025/03/31/18mylife/","content":"现在是2025年3月31日，晚上九点，我在返回北京的K412的软卧上铺上趴着写下这篇文字。 铁轨和火车轮之间似乎没有商量好彼此的节奏，总是发出吱吱的声音。火车上的各种零件也在相互碰撞,我似乎看到了一个瘦骨嶙峋的年迈老人。想起了小学或者初中的某篇文章，似乎是叫老王？不过无所谓了，这种声音的交响曲在过去一个月内陪伴了我八次十几个小时的旅程，未来一个月或许还有四次，或许更多。欠发达地区的学生的实习使命似乎就是为了促进铁道的发展 以下这些东西，可以称得上是我最近两个月的回忆录吧。 我从11月18日开始，到1月18日结束，在momenta实习了两个月。momenta是一个目标位L4的专注于智能驾驶的公司，据说已经做到了业界顶尖。 但是说实话，我在那里的实习体验非常糟糕。 工区只占了一栋楼的一层的一个角落，方寸之间大概容纳了五百余人。一进公司门，可以感觉到很明显的逼仄的感觉。地上的地毯铺满了一层，加上冬天的暖气以及人的密度，整个冬天都非常燥热。"},{"title":"简单的防抖及其迭代","path":"/2025/03/31/5js_debounce/","content":"以下情景纯属虚构，如有雷同纯属巧合 初相见这两天小刘被安排到一个项目（被老板pua中），遇到了这样一个问题：在用户登录的时候手抖点了两次，请求了两侧资源设置了两次token，但是真正完成的有效功能只有一次。 123let login = () =&gt; &#123; console.log(&quot;login&quot;)&#125; 第一次本着大国工匠的精神，老板亲自催促小刘优化这个问题 于是小刘把它做成了下面这样 1234567891011 let delay = 500let timeOutlet login = () =&gt; &#123; if (timeOut) &#123; clearTimeOut(timeOut); &#125; timeOut = setTimeout(() =&gt; &#123; console.log(&quot;login&quot;) &#125;, delay)&#125; 不错，很棒，每次点击如果和上一次相差不到0.5秒，那么取消上一次的登录请求，并做一些提示。 但是，过了两天，小刘又遇到了同样的问题，用户的登出方法以及其他的每个按钮好像都需要类似的功能 要知道，小刘是个连骑电车都嫌拿着钥匙麻烦的人 他可不愿意每次都定义好几个delay 1234567891011121314151617 let delay = 500let delay2 = 1000let delay3 = 1500let timeOutlet timeOut2let timeOut3let login = () =&gt; &#123; if (timeOut) &#123; //做一些提示 clearTimeout(timeOut); &#125; timeOut = setTimeout(() =&gt; &#123; console.log(&quot;login&quot;) &#125;, delay);&#125; 闭包突然，小刘灵光一闪，既然每份延迟都使用独立的delay和timeout，那我是不是可以用闭包记住上下文的特性，把这种类似的方法单独抽象出来？ 1234567891011export function debounce(func, delay) &#123; let timeout; return function (...args) &#123; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; console.log(&quot;debounce&quot;) func(args); &#125;, delay); &#125;&#125; 现在，小刘的代码成了这样子 12345678910111213141516171819202122232425262728 let login = () =&gt; &#123; console.log(&quot;login&quot;)&#125;let logout = () =&gt; &#123; console.log(&quot;logout&quot;)&#125;login = debounce(login, 500)logout = debounce(logout, 500)return ( &lt;&gt; &lt;button onClick=&#123; () =&gt; &#123; login() &#125; &#125;&gt;Click me &lt;/button&gt; &lt;button onClick=&#123; () =&gt; &#123; logout() &#125; &#125;&gt; &lt;/button&gt; &lt;/&gt;); 这样，就不会有那么多delay1.delay2.delay3.delay4……delayn了 小刘兴冲冲把他的代码提交了上去 再修改 —— 原型另一位同事小文兴冲冲地把更新的代码拉了下来，看到了小刘的代码 然后他浑身一颤，想到了项目发展到最后可能出现这样的情况 123456 login = debounce(login, 500)logout = debounce(logout, 500)fn = debounce(fn, 500)fn1 = debounce(fn1, 500)fn2 = debounce(fn2, 500)fn3 = debounce(fn3, 500) 每个方法执行防抖都要重新赋一个值，每个赋值都需要传入一个可能完全一样的delay 不仅如此，fn1被debounce处理之前的函数也丢失了！ 这意味着我们如果想要使用未debounce的函数，就必须要重新定义一个，而且名字还不能一样。 事实上，小文不仅仅是个喝水都懒得张嘴的懒货，而且也是一个无可救药的 ”起名困难户“， 他绝对不能让这种事情发生 所以他想到， 能不能让每个方法都具有一个debounce的方法属性，调用debounce则执行 of course, it can! 123456789101112export function debounce(delay) &#123; if (!delay) delay = 500; let timeout; const func = this;\t//这里的this是调用debounce的对象，此处是方法对象 return function (...args) &#123; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; func(args); &#125;, delay); &#125;&#125; 小文首先把debounce工具类函数改成了上面这个样子 然后又添加了这样一句话 1Function.prototype.debounce = debounce 于是 1234567891011Function.prototype.debounce = debouncefunction onClick() &#123; console.log(&quot;clickme&quot;)&#125;return ( &lt;&gt; &lt;button onClick=&#123;onClick.debounce()&#125;&gt;Click me&lt;/button&gt; &lt;/&gt;) 这样就可以在不影响原始方法的情况下使用它的debounce拉，而且还不需要传delay值! 1if (!delay) delay = 500; //如果delay不存在（null、undefined、0...） 就默认为500 需要注意的是，将 debounce 函数添加到 Function.prototype上并不是一个好的实践，因为它会改变所有函数的行为，可能导致其他依赖于 Function.prototype 的代码出现问题。此处仅仅是一个示范，如果没有严谨的文档和规约不建议在项目中使用 特殊的环境不久，小文就被优化了，他的代码流到了一位更年轻，技术更好的小刀身上， 小刀是一位资深的java工程师，非常喜欢用类、对象表示一切 不久，他就发现了这样一个问题： 123456789101112131415161718 // eslint-disable-next-line no-extend-nativeFunction.prototype.debounce = debouncelet user = &#123; name: &quot;John&quot;, sayHi() &#123; console.log(&quot;Hi, &quot; + this.name); &#125;,&#125;;return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; &#123; user.sayHi.debounce(1000)() &#125;&#125;&gt;Click me &lt;/button&gt; &lt;/&gt;) 当使用user里的sayHi调用debounce时，会报错！ 1Uncaught TypeError: Cannot convert undefined or null to object 小文刀当即力断，立刻反应出来了问题在哪，然后他把debounce改建成了如下这样 1234567891011121314export function debounce(delay) &#123; console.log(&quot;debounce&quot;); if (!delay) delay = 500; let timeout; const func = this; return function (...args) &#123; const env = this; //////新增 生命env为this if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; func.apply(env, args); ////新增 绑定func函数的词法环境（上下文）为env &#125;, delay); &#125;&#125; 不过可惜，他对javascript this机制的了解还是不是很深 深谙javascript八股之道的朋友可能已经发现了，这段代码依旧会报错！ 以下是原因 在调用user.sayHi时才会计算this的值 调用过程为： (user.sayHi).debounce()(),在user.sayHi时，this的值并没有成为”user“，而且sayHi也不是一个词法环境，所以在调用debounce，形成闭包并返回函数后，给env赋值的this时undefined 所以 …. 当然，前面说过，小刀技术水平还不错，于是他很自然地想到了，把需要成为this的环境传进去，当然，也需要兼容不需要this的函数 12345678910111213141516export function debounce(delay, env) &#123; if (!delay) delay = 500; let timeout; const func = this; return function (...args) &#123; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; if (env) &#123; func.apply(env, args); &#125; else &#123; func(...args); &#125; &#125;, delay); &#125;&#125; 然而，沉溺在修改代码的忙碌中，小刀并没有意识到可以这么做…. 123&lt;button onClick=&#123;user.sayHi.bind(user).debounce(500)&#125;&gt; Click me&lt;/button&gt; bind会返回一个绑定了user的函数 apply则是返回绑定了user的函数执行的结构 结尾说实话，在写这篇文章之前，我只准确地判断了了原型及之前的结果，对于user.sayHi.debouce的运行结果，我理所当然认为也是可以那么运行的。 除去对this的分析之外，还有一点react的小小的收获 123456789101112 let user = &#123; name: &quot;John&quot;, sayHi() &#123; console.log(&quot;Hi, &quot; + this.name); &#125;,&#125;;return ( &lt;&gt; &lt;button onClick=&#123;user.sayHi&#125;&gt;Click me&lt;/button&gt; &lt;/&gt;) 在这段代码中调用onClick，是会报错的，因为此处的user.sayHi是一个”函数名“，React会把user.sayHi赋值给onClick，然后再执行onClick() 但是，仔细一想，其实这种逻辑我早就应该知道，如下 12345678910111213141516 let user = &#123; name: &quot;John&quot;, sayHi() &#123; console.log(&quot;Hi, &quot; + this.name); &#125;,&#125;;let animal = &#123; name: &quot;Dog&quot;,&#125;let sayHi = user.sayHisayHi() ///1. 报错，因为this丢失，为undefinedsayHi.apply(user) //2. Hi, John,成功，使用apply绑定thisuser.sayHi.apply(animal) //3. Hi, Dog,成功，使用apply绑定this onClick的赋值正是第一种， 解决方法，外部包裹一个箭头函数或者function匿名函数即可，但是要注意的是这种方法对于要调用debounce的onClick却行不通， 123&lt;button onClick=&#123;()=&gt;&#123;\tuser.sayHi.debounce()()&#125;&#125;&gt;Click me&lt;/button&gt; 因为赋值给onClick的是箭头函数，而不是debounce，所以，每次调用onClick的时候都会重新创建一个debounce 顺便说一句，本来是想用ts写这篇文章的，但是在this赋值的时候会报一堆错，于是改用js想起来前些日子看到了一篇文章 ”get out typescript“ 好像题目如下，抨击了ts丢失了js最显著的优点：”灵活性“现在看来，确实如此","tags":["develop","js"]},{"title":"Cursor一键导入WebStorm样式","path":"/2024/10/14/17cursor-style/","content":"想体验Cursor的AI但是苦于vscode的快捷键不习惯？想感受vscode的丰富插件生态但是对其配色实在反感？别急… 说实话，本人一直是Webstorm的忠实拥趸 但是没办法Cursor的ai功能实在是太香了 而在webstorm中只有copilot和jetbrain的ai assistance 并且copilot不够智能、ai assistance又和vim插件非常不兼容 所幸cursor的炒鸡生态和完整的快捷键设置方案 话不多说，开始导入（文章末尾看效果） 复制链接： https://gist.github.com/Sherlocksuper/7376c4e8104ee0a87d7476045ece062f 打开cursor，文件-&gt; 首选项 -&gt; 配置文件 然后点击新建配置文件右边的导入配置文件，复制链接即可 看样式 还适配了包括但不限于以下的快捷键： ctrl shift f 触发搜索框 alt + 左右快捷键切换 终端或者编辑器（使用when表达式） and soon 不过设置中默认使用了vim编辑器 cursor打起字来还是没有webstorm做的好，并且vim编辑器bug很多","tags":["其他"],"categories":["本手"]},{"title":"JavaScript手写","path":"/2024/10/14/16js-write/","content":"Map1.回调函数的参数、返回值map的参数：当前值、index、原始数组。map可以通过第三个传递值(原始数组的引用)更改原始数组 1234567891011Array.prototype.MyMap = function (fn, context) &#123; let arr = Array.from(this) const result = [] for (let i = 0; i &lt; arr.length; i++) &#123; result.push(fn.call(context, arr[i], i, this)) &#125; return result&#125; Reduce和map一样，可以通过原始数组this更改原始数组 123456789Array.prototype.MyReduce = function (fn, initValue) &#123; const arr = Array.from(this) let res = initValue ? initValue : arr[0] const startIndex = initValue ? 0 : 1 for (let i = startIndex; i &lt; arr.length; i++) &#123; res = fn.call(null, res, arr[i], i, this) &#125; return res&#125; call&#x2F;apply123456789Function.prototype.MyCall = function (context = window, ...args) &#123; const fn = this const key = Symbol(&quot;fn&quot;) context[key] = fn const res = context[fn](...args) delete context[key] return res&#125; bind12345678910Function.prototype.myBind = function (context, ...args) &#123;// 保存当前函数 const fn = this;// 返回一个新的函数 return function (...newArgs) &#123;// 调用原函数，并把 this 指向 context，合并参数 return fn.apply(context, [...args, ...newArgs]); &#125;;&#125;; Object.create创建一个原型为proto的对象 123456789function create(proto) &#123; function F() &#123; &#125; F.prototype = proto F.prototype.constructor = F return new F()&#125; New关键字123456const MyNew = (constructor, ...args) =&gt; &#123; const instance = Object.create(constructor.prototype) const res = constructor.apply(instance, args) return typeof res === &#x27;object&#x27; ? res : instance&#125; instance关键字按照原型链向上查找，如果instance的原型是constructor的prototype，那么就是 12345678const MyInstance = (instance, constructor) =&gt; &#123; let proto = Object.getPrototypeOf(instance) while (true) &#123; if (proto === null) return false if (proto === constructor.prototype) return true proto = Object.getPrototypeOf(proto) &#125;&#125; 单例模式使用proxy进行代理proxy 1234567891011121314const proxy = (func) =&gt; &#123; let instance let handler = &#123; constructor(target, argumentList, newTarget) &#123; if (!instance) &#123; // Reflect相当于一个规范化的Object对象，用于操作对象 instance = Reflect.construct(target, argumentList, newTarget) &#125; return instance &#125; &#125; return new Proxy(func, handler)&#125; 深拷贝考虑循环引用以及Array、正则、Date等情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function deepClone(obj, hash = new WeakMap()) &#123;// 1. 基本类型：直接返回（null、undefined、布尔值、数字、字符串、Symbol） if (obj === null || typeof obj !== &#x27;object&#x27;) &#123; return obj; &#125;// 2. 检查循环引用 if (hash.has(obj)) &#123; return hash.get(obj); &#125;// 3. 处理特殊对象类型 if (obj instanceof Date) &#123; return new Date(obj); &#125; if (obj instanceof RegExp) &#123; return new RegExp(obj.source, obj.flags); &#125; if (obj instanceof Function) &#123;// 函数拷贝：这里简单处理为返回同一函数，保持函数的原始引用 return obj; &#125; if (obj instanceof Map) &#123; const mapClone = new Map(); hash.set(obj, mapClone); obj.forEach((value, key) =&gt; &#123; mapClone.set(deepClone(key, hash), deepClone(value, hash)); &#125;); return mapClone; &#125; if (obj instanceof Set) &#123; const setClone = new Set(); hash.set(obj, setClone); obj.forEach(value =&gt; &#123; setClone.add(deepClone(value, hash)); &#125;); return setClone; &#125;// 4. 创建拷贝对象并保存到哈希表中（处理循环引用） const clone = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj)); hash.set(obj, clone);// 5. 拷贝 Symbol 属性 const symbolKeys = Object.getOwnPropertySymbols(obj); symbolKeys.forEach(symKey =&gt; &#123; clone[symKey] = deepClone(obj[symKey], hash); &#125;);// 6. 拷贝普通属性 const keys = Object.keys(obj); keys.forEach(key =&gt; &#123; clone[key] = deepClone(obj[key], hash); &#125;); return clone;&#125;","tags":["JavaScript"],"categories":["本手"]},{"title":"前后端（React + Node）项目部署全流程及常见问题解析","path":"/2024/09/14/14deploy/","content":"粗糙，仅留档供个人使用记录一下部署用到的工具以及踩过的坑 项目: 前端： javascript、react、vite 后端： node typescript 当然不止这些，不过其他框架、工具之类的，不记也罢 大致流程 购买一台服务器 配置环境 把项目放到服务器上(是否打包看个人情况) 运行 其中购买服务器暂且按下不表 配置环境安装node环境和npm (配套镜像)此处使用nvmnode version manager (node 版本管理工具) github网址：https://github.com/nvm-sh/nvm 安装nvm12345curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash# orwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash 使用镜像如果安装nvm太慢,可以使用淘宝镜像 123export NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/nodecurl -o- https://npmmirror.com/mirrors/nvm/install.sh | bash 激活安装完成后，运行以下命令来加载 NVM： 1234source ~/.bashrc如果是Zshsource ~/.zshrc 或者运行 12export NVM_DIR=&quot;$([ -z &quot;$&#123;XDG_CONFIG_HOME-&#125;&quot; ] &amp;&amp; printf %s &quot;$&#123;HOME&#125;/.nvm&quot; || printf %s &quot;$&#123;XDG_CONFIG_HOME&#125;/nvm&quot;)&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 第一行设置了一个环境变量 $NVM_DIR，它指向 NVM 的安装目录。第二行检查 $NVM_DIR&#x2F;nvm.sh 文件是否存在，如果存在，就执行它。这一步是加载 NVM 的必要步骤。 确保 NVM 正确安装，您可以运行以下命令检查 NVM 版本： 1nvm --version 安装Node.js使用 NVM 安装 Node.js 123nvm install --ltsnode --version 如果想安装或切换到其他版本的 Node.js，可以运行： 12nvm install &lt;version&gt;nvm use &lt;version&gt; 例如，安装并使用 Node.js 16： 12nvm install 16nvm use 16 npm镜像在安装npm 包的时候可能会比较慢，配置国内镜像 腾讯云镜像源npm config set registry http://mirrors.cloud.tencent.com/npm/ 淘宝镜像源npm config set registry https://registry.npmmirror.com 华为云镜像源npm config set registry https://mirrors.huaweicloud.com/repository/npm/ 配置Git安装git12345sudo apt updatesudo apt install gitgit --version 配置SSH1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; -b 4096 其中-t 是加密方式-C 是常用的email标识号(亲测配不配email似乎没用)-b 生成的密钥大小，不配也行 12345//查看私钥cat ~/.ssh/id_rsa// 查看公钥cat ~/.ssh/id_rsa.pub 查看并复制公钥打开github的setting 之后就可以使用ssh拉取代码啦 1git clone xxxx 部署推荐一个工具:finalshell 图形化ssh、fcp协议 不打包部署这一部分比较简单 首先通过git拉取对应的文件以下是我的文件夹–back_end|_front_end 其中back_end是后端node程序，通过npm start启动，front_end是vite，通过npm run dev启动 小tips:通过package.json脚本可以一键启动多个程序 12345678&#123; &quot;devDependencies&quot;: &#123; &quot;concurrently&quot;: &quot;^8.2.2&quot; &#125;, &quot;scripts&quot;: &#123; &quot;start-all&quot;: &quot;concurrently \\&quot;npm start --prefix back_end\\&quot; \\&quot;npm run dev --prefix front_end\\&quot; &quot; &#125;&#125; –prefix： 在当前文件夹的某个目录运行 之后在根目录运行即可 12npm run start-all 打包部署重要问题大小写敏感问题windows系统对于文件路径和文件名大小写是不敏感的 比如 import 路径.&#x2F;Test&#x2F;photo.tsx和 实际路径.&#x2F;test&#x2F;Photo.tsx 在window系统上，如果你开发的时候把test目录改成了Test目录git是不会识别到更改的 但是linux在上面的导入中，会报错 window启用大小写敏感： 1fsutil file setCaseSensitiveInfo &quot;C:\\your\\folder\\path&quot; enable 把”C:\\your\\folder\\path” 替换为你的文件目录名不过只能对空目录用，先把文件转移除去，设置之后再放回来 Linux进程相关（如何保活后台应用 ?）在linux中，有下面几个概念： 概念 描述进程组：一个或多个进程的集合，每一个进程组都有唯一一个进程组ID，即进程组会话器：一个或多个进程组的集合，有唯一一个会话期首进程（session leader）. 会话期ID为首进程的ID控制进程:与控制终端连接的会话期首进程叫做控制进程 当用户登录到一个终端时，系统会为这个登录会话创建一个会话（session）。从用户登录到退出的整个过程中，所有在这个终端上运行的进程都属于同一个会话。 进程和进程组：每个进程都有一个独立的进程ID（PID），但它们还归属于一个更大的组织单位，称为进程组。一个进程组可以包含多个进程，并且有一个唯一的进程组ID。进程组允许多个进程一起执行操作，比如使用管道符号 “|” 连接的命令。 会话和会话首进程：一个 会话 包含一个或多个进程组。每个会话都有一个唯一的领导者进程，称为 会话首进程，并且它的ID就是会话的ID。 控制进程和控制终端：当一个会话与一个终端（如SSH连接的终端）关联时，负责与这个终端通信的进程就是控制进程，它通常是会话首进程。当终端检测到网络断开时，会向控制进程发送一个挂断信号（SIGHUP）。 挂断信号的传播：如果控制进程收到SIGHUP信号并退出，会话中的所有前台进程组也会受到影响并终止。如果某个进程组中的进程已经停止，系统还会发送SIGHUP和SIGCONT信号，尝试重新启动它们。 最后:当SSH会话断开时，系统会给控制进程发送一个SIGHUP信号，导致整个会话中的进程都被终止。这就是为什么当SSH连接关闭后，正在执行的任务也会随之取消。简而言之，SSH会话打开时运行的所有命令和进程（如bash）都是它的子进程。一旦SSH连接断开，系统会终止所有相关进程，导致未完成的任务被取消。","tags":["开发","部署","妙手"],"categories":["开发"]},{"title":"一码多用——跨端发展史","path":"/2024/09/12/15cross-end/","content":"这篇文章以跨端技术的演进过程为中心，重点分析了Cordova、React Native和Flutter的渲染原理，尤其深入介绍了Flutter的独特三层架构。文章详细阐述了Flutter自有的Skia图形引擎和Dart语言的作用，以及其如何通过渲染流水线和双缓冲机制优化UI性能。 跨端技术的历史说实话，我是那种很反感教科书一类的教案上来就讲历史而不是实操的人 Cordova 和 Ionic 诞生于2009年。其中，Cordova是跨端框架，基于WebView和JSBridge，Ionic诞生时是基于Cordova的UI组件库 React Native Facebook于2015年推出的一种跨端开发框架。并不使用WebView和JSBridge其使用的是一种 “Native” 方法，我们后面会讲到 Flutter是笔者最早接触到的跨端框架，是Google于2017年推出的一种跨端开发框架。 原理一句话讲解 Cordova&#x2F;Ionic: 使用WebView嵌入Web应用，对于原生的功能如相机等需要用JSBridge调用 React Native: 使用JavaScript和React编写逻辑，映射到iOS和Android的原生组件上 Flutter: 自有的Skia图形引擎渲染UI, 自研_三层架构_降低多端成本 CordovaWebViewWebView是一个基于WebKit引擎的浏览器组件,实现了在移动应用中嵌入网页内容原理: WebView 内部使用了操作系统提供的浏览器内核 (Android的Chrome、IOS的Safari)来渲染网页，类似一个迷你的浏览器 WebView是原生应用的一部分，事实上是一个UI组件类似于按钮、文本框 WebView允许网页和原生应用通信，通过JSBridge实现，网页和原生应用可以互相调用对方的功能 JSBridge什么是JSBridge ? JSBridge is a bridge between the JavaScript engine and the native platform code. JSBridge是JavaScript引擎和原生平台（Android、IOS）的一个桥梁它把javascript代码转化成原生平台能够看懂的语言并调用，然后将调用的结果返回给webView的界面 过程1. 翻译为原生可理解的语言 Web 端调用 JSBridge：Web 页面使用 JavaScript 代码，通过一个暴露的 window.bridge 对象（或其他命名）来调用原生功能. JSBridge 传递：JSBridge 在 WebView 中监听这些调用（通过注册的方法），并将这些 JavaScript 调用转换为特定的指令，如 “takePhoto”。 原生调用：原生应用事先会在 JSBridge 中提供一系列功能，如拍照、获取地理位置等。JSBridge 将 “takePhoto” 这样的指令映射到原生应用对应的功能调用， 2. 将指令发送给对应平台JSBridge 通过两种主要方式将 Web 页面的请求传递给原生应用： 1. URL 原理：在 WebView 中，JavaScript 可以通过修改 URL 的方式与原生应用通信。JSBridge 会构造一个特定的 URL 格式。例如(以拍照为例) bridge://takePhoto?params=...，这个 URL 可以被原生识别。 触发原生响应：WebView 拦截这个 URL，识别其内容并通知原生代码执行相应的功能（如调用相机）。 2. 注入 JavaScript 接口 原理：原生应用可以主动注入一段 JavaScript 代码到 WebView 中，比如通过 WebView.addJavascriptInterface（在 Android中），这段 JavaScript 暴露出一系列接口让 Web 页面调用。 触发原生响应：Web 页面通过调用这些接口与原生交互，类似于直接调用本地 JavaScript方法，但这些方法最终由原生实现。比如 window.NativeInterface.takePhoto() 这样的接口实际会触发原生代码。 3. 原生应用执行并返回结果 原生处理：一旦原生应用接收到 Web 发来的指令（例如通过 URL 或 JavaScript 接口），它会执行相应的功能，比如启动相机等。 返回数据到 Web：原生应用完成任务后，通常会将结果通过 JSBridge 返回给 Web 页面。之后通过 调用时候设置的 JavaScript 回调函数进行对应的处理， 原生应用在完成任务后会调用这个回调函数，将数据传回 Web 页面。之后由web页面进行相应 缺点优点自不必说,我们来着重关注一下缺点 在使用过程中，会频繁调用JSBridge，而JSBridge毕竟不是原生的API，所以会有一定的通信延迟和时间损耗 使用WebView过程中，需要经历 “浏览器的渲染过程” ，而原生代码直接使用操作系统提供的图形控件，避免了多层抽象和额外的处理步骤 原生控件可以更直接的利用GPU加速，而浏览器的GPU加速依赖于内部的实现和优化(增加了额外的抽象层,并且不同浏览器性能不一) JavaScript 代码需要经过解释、编译和优化等多个步骤，相比直接执行原生代码，效率较低 React NativeReact Native 和 Cordova&#x2F;Ionic 的区别在于，React Native 不使用 WebView，而是直接使用一种名为 “Native” 的方法。 这种方法能够直接将Javascript界面以及点击、动画等交互变成对应平台的原生组件。(ps: 这里的方法指的是method而非function) React Native 和 Weex 通过一种桥梁机制，使用 JavaScript 来定义应用的界面布局和交互逻辑。但最终实际显示的界面不是基于 Web(WebView) 技术（如 HTML&#x2F;CSS），而是通过调用手机操作系统的原生 UI 件来呈现的。 什么是 Native 的控件？“Native”意为”原生”，指的是对应的平台Native 控件（Native Components）指的是手机操作系统（如 iOS、Android）自带的用户界面组件。这些控件是系统级别的，专门为该操作系统设计，通常表现更流畅、性能更好，用户体验更接近“原生应用”。 一些常见的 Native 控件包括： iOS 上的原生控件： UIView: 用于显示内容的基础容器。 UIButton: 原生的按钮组件。 UILabel: 用于显示文本的组件。 Android 上的原生控件： View: Android 上的基础视图。 Button: 用于用户点击的按钮。 TextView: 用于显示文本的控件。 如何转化为 Native 控件？在 React Native 和 Weex 中，虽然开发者使用 JavaScript 来编写界面和交互逻辑，但这些框架背后会有一个桥接层（Bridge）。 桥接层负责将 JavaScript 描述的界面结构（如 &lt;View&gt;、&lt;Button&gt; 等）转化为操作系统的原生控件。 同时,桥接层也允许 JavaScript 和 原生 直接按互相调用对方。 例如： 在 React Native 中，开发者可能会用这样的 JavaScript 来创建一个按钮： 1&lt;Button title=&quot;Click Me&quot; onPress=&#123;handleClick&#125; /&gt; 虽然这段代码看上去像是 Web 的 JSX 代码，但实际上 React Native 背后的桥接机制会将这个按钮组件映射为 iOS 上的 UIButton 或 Android 上的 Button。 也就是说，当你运行这个应用时，用户实际看到和交互的是原生平台的按钮，而不是一个 HTML 按钮。 为什么要转化为 Native 控件？ 性能：原生控件由操作系统直接渲染，性能比 WebView 中的 HTML&#x2F;CSS 渲染更好。操作系统可以更高效地处理这些组件的渲染、动画等任务。 用户体验：由于使用了系统级别的组件，控件的样式、交互效果和原生应用一致，使得用户体验更加流畅自然，尤其是在复杂的界面上。 系统功能：原生控件可以更容易地与操作系统的其他功能（如相机、通知、定位等）集成。 Flutter本篇的目的就是以Flutter为核心， Flutter 是 Google 于 2017 年推出的一种跨端开发框架，它的原理和上文的两个跨端方法有所不同。 Flutter 不借助原生的渲染能力（即上文提到的Native）,而是**自己实现了一套渲染逻辑** Flutter 的三板斧: 自有的 Skia 图形引擎： Dart语言： 自研的三层架构： 下面我们以图像的渲染原理来介绍前两板斧的作用(Skia和Dart) 图像的渲染原理(以Flutter为例)在这之前，可以先看看我的这一篇文章 https://holdme.fun/2024/07/10/9flutter-react/https://holdme.fun/2024/07/10/9flutter-react/ 在Flutter中，图像显示的基本原理依然需要CPU、GPU和显示器的协同配合，但其框架对渲染管线(通俗点说就是渲染的步骤)有一些独特的实现。让我们从Flutter渲染的角度进一步详细说明整个过程： 1. CPU的角色：Flutter渲染的初步计算 在Widget树的构建：CPU的任务是根据用户输入、应用状态变化以及开发者编写的代码，构建或重建Widget树。Widget树只是对UI界面的描述。 Element树和RenderObject树： Element树：Widget树在被构建&#x2F;更改后，CPU会生成与之对应的Element树。Element树的每个节点表示Widget的实例化。 RenderObject树：CPU还会创建和更新RenderObject树，这个树是负责实际布局和渲染的对象。RenderObject树保存了具体的布局和绘制信息（如尺寸、位置等），而CPU负责计算每个节点的布局。 布局计算：Flutter的布局过程是自顶向下进行的。CPU会先确定父节点的尺寸和约束，然后再向子节点传递这些约束。通过这种递归过程，Flutter计算出每个Widget的大小和位置。 2. GPU的角色：Flutter渲染的实际执行 绘制指令生成：布局确定之后，CPU会将布局和绘制相关的数据打包成绘制指令。Flutter使用Skia图形库，Skia是一种跨平台的2D图形引擎。CPU生成的绘制指令通过Skia传递给GPU，由GPU完成实际的像素绘制。 绘制流水线： Layer树：(CPU生成)Flutter引入了Layer（图层）的概念，每一帧的渲染会产生一个Layer树。**Layer树是RenderObject树的优化形式，包含了具体的绘制信息和层次结构**。有助于高效地管理和合成多个绘制操作。 合成：当Layer树生成后，CPU会将其交给GPU进行合成。将不同的Layer按照正确的顺序组合并转换为可以显示的帧数据。 3. 帧缓冲区与VSync：协调显示器刷新 帧缓冲区的存储：当GPU完成了所有图层的合成并生成最终的像素数据后，数据会被存储在帧缓冲区中。帧缓冲区是GPU专门用于保存一帧完整图像的区域。(事实上就是一群内存块) 垂直同步（VSync）机制：Flutter使用VSync信号来协调GPU渲染和显示器刷新率。在大多数设备上，显示器的刷新率为60Hz，这意味着显示器每秒更新60次。Flutter会通过VSync信号来确保每次显示器刷新时，能够显示最新的一帧图像，避免撕裂现象。 帧速率控制：Flutter的渲染引擎通过监听VSync信号，确保在适当的时机开始渲染新的一帧。VSync信号通常每秒发送60次（即60Hz），当Flutter接收到VSync信号时，它会驱动新的渲染管线(驱动新的渲染步骤)，计算、生成和合成下一帧。 4. Flutter的双缓冲机制 前后缓冲区：Flutter使用双缓冲机制来确保帧的平滑显示。后缓冲区是GPU正在渲染的一帧数据，而前缓冲区则是即将显示的完整帧。当后缓冲区渲染完成并在VSync信号到来时，缓冲区会交换，这样前缓冲区的数据被显示器读取并显示。 Flutter三层架构Flutter的架构采用分层设计，从下到上分为三层Embedder、Engine和Framework。 最下层是Embedder层，实现了和操作系统对接，渲染、线程设置以及平台相关特性 中间层是Engine层，包含Dart、Skia，Skia为上层提供了调用底层渲染和排版的能力，Dart则为Flutter提供了运行时调用Dart和渲染引擎的能力。而Engine层的作用，则是将它们组合起来，从它们生成的数据中实现视图渲染 Framework层则是一个用Dart实现的UI库，包含了常规的图形、动画等功能。 总结值得一提的是，Flutter在笔者目前的使用体验来看，他还只是一个类似于UI库的存在 对于Android和IOS的原生服务，比如 通知提示、相机调用等，还是需要通过原生的方法来调用 在Flutter里面，这个叫 “MethodChannel” 引申动画中的双缓冲机制例子：假如我们有一个动画，每秒钟60帧，每一帧都要变化 假设这个动画为：第一帧为红色、第二帧为绿色 第一帧的渲染:CPU加工出需要显示的内容，放入后缓冲区GPU处理后缓冲区的渲染，当VSync来到的时候，后缓冲区和前缓冲区交换第一帧的数据现在在前缓冲区,显示器会读取它并显示,屏幕变成红色 第二帧的渲染:CPU加工出需要显示的内容，放入后缓冲区GPU处理后缓冲区的渲染，当VSync来到的时候，后缓冲区和前缓冲区交换第二帧的数据现在在前缓冲区,显示器会读取它并显示,屏幕变成绿色 (ps:是不是特别像React里的虚拟Dom机制?) 明晰几个概念 渲染：把数据转化为图像的过程，在开发中大多指把“数据”转化为“可视化的图像”,即：将抽象的界面结构（如Widget、形状、文本等）转化为可以显示在屏幕上的像素数据 显示：把渲染好的图像显示在屏幕上","categories":["妙手"]},{"title":"javascript-词法环境","path":"/2024/08/14/12lexical-env/","content":"词法环境：每个运行的函数、代码块、以及整个脚本，都有一个词法环境，这个词法环境是一个内部隐藏的关联对象 词法环境包括两个部分： 存储自己作用域内所有的变量 对外部词法环境的引用 思考逻辑：声明一个变量是在这个变量所处地方的词法环境对象（特殊内部对象的属性）添加一个属性修改一个变量也是修改词法环境内部的一个属性 不过，词法环境只是存在于规范层面，用来具体的描述对象是怎么工作的事实上并不存在与之对应的对象 词法环境间的引用在一个函数运行时，会自动创建一个新的词法环境来储存他内部的局部变量和参数 此时，我我们有两个词法环境一个是函数内部的，一个是全局、函数外部的 当代码要访问一个变量的时候，首先会搜索内部词法环境，然后搜索外部，直到全局词法环境或者找到自己要的 注意：每次某个函数被调用时，都会创建一个新的词法环境对象，词法环境中对外部对象的引用是一样的所有的函数在“诞生”时都会记住创建它们的词法环境。所有函数都有名为 [[Environment]] 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。 使用例子：闭包闭包指的是一个函数可以记住外部变量并且可以访问这些变量，除了new Function(string)之外的所有函数都是天生带有闭包 javascript的函数会通过[[Environment]]属性记住创建的位置、访问外部变量 示例 当使用makeCounter()是，改函数创建一个自己的词法环境，并包含count这个属性之后，调用counter时，会创建一个counter的词法环境，之后添加对外部makeCounter词法环境的引用，并尝试搜索count但是由于counter词法环境不存在count,于是便会向myCounter搜索 调用counter时，触发 count++ 代码，此时，首先会在counter的此法环境中搜索count，由于counter函数的词法环境不存在其他变量，于是便会向上搜索，更改myCounter的词法变量的属性 当我们再次调用makCounter()时，makeCounter会再次创建一个词法环境，这个词法环境包含其内部的新的count 词法环境结构如下：","tags":["本手"]},{"title":"参与开源四个月，我干了什么？","path":"/2024/08/14/12what-I-Do-GLCC/","content":"上接我的OSPP那篇文章，OSPP落选之后，我又报名了GLCC，由于已经做过一部分项目，所以也算是顺利入选了。 项目地址：Casibase演示网站：Casibase演示网站","tags":["本手"]},{"title":"TypeScript All","path":"/2024/08/14/13-3TypeScript/","content":"☆☆接口和类型别名☆☆interface和type 接口创建了一个新的名字，可以在其他地方使用，类型别名不创建新的名字，而是类型的引用 类型别名不能被或者extends、implements其他类型，interface对于拓展是开放的 多个同名的interface会合并（相同属性声明为不同类型时候会报错），type则会报错 type可以表示联合类型和交叉类型，interface则会报错 使用tsc编译之后,type不会存在，因为他只是“引用”,interface也不会存在，因为他只是“规范” 如果使用type something &#x3D; string，type依旧不会存在 12type Animal = &quot;fish&quot; | &quot;cow&quot;interface Animal = &quot;fish&quot; | &quot;cow&quot; //报错 ★★反向映射★★12345enum Enum &#123; A&#125;let a = Enum.A;let nameOfA = Enum[a]; // &quot;A&quot; ★★可能会将编译为★★ 123456var Enum;(function (Enum) &#123; Enum[Enum[&quot;A&quot;] = 0] = &quot;A&quot;;&#125;)(Enum || (Enum = &#123;&#125;));var a = Enum.A;var nameOfA = Enum[a]; // &quot;A&quot; ★★高级技巧★★声明类时 12345678910111213class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return &quot;Hello, &quot; + this.greeting; &#125;&#125;let greeter: Greeter;greeter = new Greeter(&quot;world&quot;);console.log(greeter.greet()); 创建了一个构造函数，会在new创建实例的时候调用。 上面的代码被编译之后： 12345678910111213let Greeter = (function () &#123; function Greeter(message) &#123; this.greeting = message; &#125; Greeter.prototype.greet = function () &#123; return &quot;Hello, &quot; + this.greeting; &#125;; return Greeter;&#125;)();let greeter;greeter = new Greeter(&quot;world&quot;);console.log(greeter.greet()); 回顾：使用new函数会发生什么？ 创建一个空对象，成为newInstance（新的实例） 如果构造函数的prototype是一个对象，那么把newInstance的原型指向prototype，否则newInstance为一个普通对象，原型为Object.prototype 使用给定参数执行构造函数，并把newInstance绑定为this上下文 如果构造函数返回非原始值，则返回值为new的结果，否则返回newInstance any 和 unknow的区别 unknow是类型安全的any，unknow类型的值只能赋值给unknow和any类型的变量 any类型的值可以赋值给任何类型的变量 any 类型是TypeScript中最不安全的类型，它允许赋值给任何类型，也可以从任何类型赋值过来。这意味着使用 any 类型时，TypeScript不会进行任何类型检查，这基本上和使用JavaScript的动态类型特性一样。 unknown 类型是TypeScript中安全类型的一种，它是 any 类型的类型安全版本。使用 unknown 类型时，你必须先对变量进行检查或类型守卫，才能访问其属性或调用其方法。 举个例子 123456789101112function processAny(value: any) &#123; console.log(value.toUpperCase()); // 假设 value 是一个字符串 return value * 10; // 这里 TypeScript 不会报错，即使 value 不是数字&#125;function processUnknow(value: unknow) &#123; console.log(value.toUpperCase()); // 假设 value 是一个字符串 return value * 10; // 这里 TypeScript 不会报错，即使 value 不是数字&#125;processAny(123)processAny(&quot;123&quot;)processUnknow(123)processUnknow(&quot;123&quot;) 在这个例子里，processAny的两个都不会报错processUnknown的两个调用都会报错，如果不希望报错我们需要： 123456789function processUnknow(value: unknow) &#123; if (typeof value === &quot;string&quot;)&#123; console.log(value.toUpperCase()); // 假设 value 是一个字符串 &#125; if (typeof value === &quot;number&quot;)&#123; return value * 10; // 这里 TypeScript 不会报错，即使 value 不是数字 &#125; return &quot;1&quot;&#125; 在调用之前进行类型断言 typescript 是怎么进行类型检查的，在哪个阶段发挥作用TypeScript 代码首先通过 TypeScript 编译器（tsc）进行编译。编译过程主要包括以下几个阶段： 解析：将 TypeScript 代码解析成抽象语法树（AST）。 类型检查：在 AST 上进行类型检查，确保代码符合类型系统的要求。 转换：将 TypeScript 代码转换成等价的 JavaScript 代码。包括: 处理 TypeScript 特有的语法，如类型注解、接口、类等，并将其转换为 JavaScript 语法。 输出：生成编译后的 JavaScript 代码，通常是一个或多个 .js 文件。","tags":["本手"],"categories":["TypeScript"]},{"title":"TypeScript Part2","path":"/2024/08/14/13.2TypeScript/","content":"TypeScript2模块 m模块在自身作用域执行，不是全局作用域 除非使用export导出，否则定义在内部的变量都是不可见的 模块使用模块加载器导入其他模块， 模块加载器用于在执行此模块代码之前去查找并执行这个模块所有的依赖 JavaScript模块加载器是服务于Node.js的CommonJS和服务于Web应用的Require.js。 任何包含顶级import或者export的文件都为一个模块，如果都不带，那么内容为全局可见的 导出导出语句12export &#123; ZipCodeValidator &#125;;export &#123; ZipCodeValidator as mainValidator &#125;; 使用as可以重命名 重新导出12345678export class ParseIntBasedZipCodeValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; parseInt(s).toString() === s; &#125;&#125;// 导出原先的验证器但做了重命名export &#123;ZipCodeValidator as RegExpBasedZipCodeValidator&#125; from &quot;./ZipCodeValidator&quot;; 不会在当前模块导入或者定义一个新的局部变量 导入12345import &#123; ZipCodeValidator &#125; from &quot;./ZipCodeValidator&quot;; //普通导入import &#123; ZipCodeValidator as ZCV &#125; from &quot;./ZipCodeValidator&quot;; //重命名import * as validator from &quot;./ZipCodeValidator&quot;; //导入全部，用validator代表这个模块let myValidator = new validator.ZipCodeValidator(); 默认导出 类和函数声明可以直接被标记为默认导出。 标记为默认导出的类和函数的名字是可以省略的。 12345const numberRegexp = /^[0-9]+$/;export default function (s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s);&#125; default的导出可以是一个值 export = 和 import = require() 在CommonJS和AMD的环境里有一个exports变量，包含着一个模块的所有导出内容 exports可以被赋值为一个对象，类似于es6的默认导出 为了兼容CommonJS和AMD提供了export &#x3D; 语法 若使用export =导出一个模块，则必须使用TypeScript的特定语法import module = require(&quot;module&quot;)来导入此模块。 1234567//test.tsexport = &#123; hello: &#x27;world&#x27;&#125;///导入import zip = require(&quot;./test.ts&quot;); 命名空间 nameSpace“内部模块” 提取逻辑，记录的同时不担心与其他对象产生命名冲突 相同namespace即使在不同文件也是同一个明明空间，与接口的合并同工 简化命名空间操作: import q &#x3D; x.y.z （用q代表x.y.z，起个名字） 模块和命名空间的区别 模块有自己的作用域，只有被导出才能被其他文件引用。namespace可以在全局引用，即使不导出 123456789// global.tsnamespace MyNamespace &#123; export class MyClass &#123; constructor(public name: string) &#123;&#125; &#125;&#125;// main.tslet instance = new MyNamespace.MyClass(&#x27;example&#x27;); 模块是文件级别的，用import和export进行管理，namespace在全局通过代码自行组织 使用场景：模块是 TypeScript 和 ES6 中推荐的组织代码的方式，适用于大型项目。而命名空间主要用于组织全局变量，适用于较小的项目或者为了向后兼容 ps:可以把模块比作每个城池，命名空间比作教会 模块解析相对导入 以 &#x2F; .&#x2F; ..&#x2F; 开头的 相对于导入他的文件 非相对 所有其它形式的导入 相对于baseUrl或者路径映射 模块解析策略Classic 之前的默认解析策略，为了向后兼容而保留 相对导入模块相对于导入他的文件解析 1234/root/src/folder/A.ts/root/src/folder/moduleB.ts/root/src/folder/moduleB.d.ts 非相对模块的导入，编译器会从包含文件的目录依次向上级目录遍历 123456789101112//有一个对moduleB的非相对导入import &#123; b &#125; from &quot;moduleB&quot;//它是在/root/src/folder/A.ts文件里，会以如下的方式来定位&quot;moduleB&quot;：/root/src/folder/moduleB.ts/root/src/folder/moduleB.d.ts/root/src/moduleB.ts/root/src/moduleB.d.ts/root/moduleB.ts/root/moduleB.d.ts/moduleB.ts/moduleB.d.ts Node相对路径： 相对路径文件是否存在 如果不存在文件，检查是否有目录，如果有目录，检查是否【有package.json文件并且这个文件制定了一个main路径】，如果发现了package.json中有main路径，则会引用 检查目录的路径拼接main路径 123/root/src/moduleB/package.json包含了&#123; &quot;main&quot;: &quot;lib/mainModule.js&quot; &#125;，那么Node.js会引用/root/src/moduleB/lib/mainModule.js。 检查/root/src/moduleB目录是否包含一个index.js文件。 这个文件会被隐式地当作那个文件夹下的”main”模块。 非相对路径: 会在node_modules里面查找 假设require(”moduleB”) 首先会查找 &#x2F;node_modules&#x2F;moduleB.js &#x2F;node_modules&#x2F;moduleB&#x2F;package.json(如果指定了main属性) &#x2F;node_module&#x2F;moduleB&#x2F;index.js 之后向上跳目录 附加的模块解析标记由于工程源码和输出结构不同，需要经过转换。 包括把ts编译为js，将不同位置的依赖拷贝至一个输出位置。 最终结果就是： 运行时的模块名与包含它们声明的源文件里的模块名不同。 或者最终输出文件里的模块路径与编译时的源文件路径不同了。 Base URL设置baseUrl来告诉编译器到哪里去查找模块。 所有非相对模块导入都会被当做相对于baseUrl。 baseUrl的值由以下两者之一决定： 命令行中baseUrl的值（如果给定的路径是相对的，那么将相对于当前路径进行计算） ‘tsconfig.json’里的baseUrl属性（如果给定的路径是相对的，那么将相对于‘tsconfig.json’路径进行计算） 注意相对模块的导入不会被设置的baseUrl所影响，因为它们总是相对于导入它们的文件 路径映射TypeScript编译器通过使用tsconfig.json文件里的&quot;paths&quot;来支持的声明映射。 下面是一个如何指定jquery的&quot;paths&quot;的例子。 12345678&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, // This must be specified if &quot;paths&quot; is. &quot;paths&quot;: &#123; &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery&quot;] // 此处映射是相对于&quot;baseUrl&quot; &#125; &#125;&#125; path是相对于baseUrl的 (如果是非相对名，则直接拼接，如果是相对名，则进行对应的改变) 装饰器装饰器是实验特性 启用: 123456&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;ES5&quot;, &quot;experimentalDecorators&quot;: true &#125;&#125; 定义：它能够被附加到类声明，方法，访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。 装饰器工厂 类装饰器 target此处指Person 属性装饰器 target为Person类 attr 为 ”name“ 方法装饰器 target为Person类 propertyKey为方法的属性键值 descriptor为属性描述 装饰器组合多个装饰器应用在一个生命上时 由上到下对装饰器表达式求知（即获取返回的函数部分） 由下到上把函数结果进行调用 1234567891011121314151617181920function f() &#123; console.log(&quot;f(): evaluated&quot;); return function (target, propertyKey: string, descriptor: PropertyDescriptor) &#123; console.log(&quot;f(): called&quot;); &#125;&#125;function g() &#123; console.log(&quot;g(): evaluated&quot;); return function (target, propertyKey: string, descriptor: PropertyDescriptor) &#123; console.log(&quot;g(): called&quot;); &#125;&#125;class C &#123; @f() @g() method() &#123;&#125;&#125; 在控制台里会打印出如下结果： 1234f(): evaluatedg(): evaluatedg(): calledf(): called 装饰器求值原则：由内到外，由小到大 类中不同声明上的装饰器将按以下规定的顺序应用： 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。 参数装饰器应用到构造函数。 类装饰器应用到类。 Declare告诉编译器这个变量是存在的 应用于一些不使用ts的库，但是需要引用到ts里面，需要有一个类型，就可以用declare来声明一下 1234567891011//index.jsfunction showMessage(message)&#123;\tconsole.log(message)&#125;//test.tsshowMessage(&quot;name&quot;)//common.d.ts//如果删去则报错declare showMessage(message:string):void 引入类型描述的时候会自动引入对应的js的文件 同名引入 对于自己写的模块，会默认引用与该文件同名的类型声明文件。比如有一个foo.js和foo.d.ts，如果使用import会自动由foo.d.ts提供 自动引用 第三方库都有@types&#x2F;xxx ，declare文件 配置这个，type在的目录 declare module、namespace12345declare module &quot;jquery&quot; &#123;\texport let fn:string&#125;jquery.fn 为外部属性新增1234567891011121314//index.tsexport interface A &#123;\tvalue1:string&#125;//test.tsimport &#123;A&#125; from &quot;index.ts&quot;declare module &quot;index.ts&quot; &#123;\tinterface A &#123; value2:string\t&#125;&#125;//接口合并 三斜线指令包含单个XML标签的单行注释，注释的内容会作为编译器指令使用 只能仿造包含他的文件的最顶端 其前面只能出现单行或者多行注释 如果前面有语句或声明，那么会被当做普通的单行注释 1/// &lt;reference path=&quot;...&quot; /&gt; 专门用来引用.d.ts文件 1/// &lt;reference types=&quot;...&quot; /&gt; 预处理解析所有三斜线引用的指令，把对应的文件添加到编译的过程中 路径是相对于包含他的文件的 如果引用的的文件不存在会报错—noResolve如果使用了noResolve，三斜线会被忽略 12345/// &lt;reference path=&quot;...&quot; /&gt; 声明对文件的依赖/// &lt;reference types=&quot;node&quot; /&gt; 声明对包的依赖//表明使用了@types/node/index.d.ts里面生命的名字 在编译阶段生成的声明文件，编译器会自动添加 &#x2F;&#x2F;&#x2F; 配置这个，type在的目录","tags":["本手"],"categories":["TypeScript"]},{"title":"TypeScript Part1","path":"/2024/08/14/13.1TypeScript/","content":"TypeScript常见类型 布尔 数字 number 字符串 string 数组 元组 let x :[string,number] &#x3D; [’hello’,10] 枚举 enum Any 不检查，直接通过编译 void 没有任何类型，只能赋值为undefined 和 null null undefined Never 永远不存在类型， 必会抛出异常或者根本不会有返回值 Object非原始类型 类型断言 尖括号、as 接口正常值12345678910interface LabelledValue &#123; label: string; option?:string; readonly name:string;&#125;function read(conf:LabelledValue)&#123;&#125;read(&#123;label:&quot;123.&quot;,name:&quot;liming&quot;,color:&quot;red&quot;&#125;) 添加 ？ 为可选，可不传递 指挥检查是否存在，不会检查顺序 readonly 只读，不可改变 如果一个对象字面量存在任何“目标类型”不包含的属性时，会报错,如上面的color 函数123456789interface SearchFunc &#123; (source: string, subString: string): boolean; // name:string;&#125;let mySearch: SearchFunc;mySearch = function(src: string, sub: string): boolean &#123; let result = src.search(sub); return result &gt; -1;&#125; 函数的入参不需要和接口定义的名字一样 如果不在入参处设置类型断言，会逐个进行匹配 可索引类型1234interface StringArray &#123; [index: number]: string; readonly [name:string]: number;&#125; 当遇到number类型的时候，需要返回string类型数据 两种索引签名，number、string 你可以将索引签名设置为只读，这样就防止了给索引赋值： 类类型123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 不检查私有成员，只检查公有 接口继承12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = &quot;blue&quot;;square.sideLength = 10;square.penWidth = 5.0; 混合类型1太过于邪恶，避之 接口继承类 继承类的成员，但是不继承实现 比如类中有一个state：”fulfilled“，会继承state，但不会继承fulfilled 继承 ”继承类的接口“ 的类必须再次实现类的属性 类修饰符 public private protected 可以在派生类中访问（即子类） readonly 只读 存取器1234567891011class Employee &#123; private _fullName: string; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; console.log(newName); &#125;&#125; 存取器要求设置为ES5或者更高，不支持降级到ECMA3 只带有get的存取器默认推断为readonly 抽象类1大致和java相同 ★★高级技巧★★声明类时 12345678910111213class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return &quot;Hello, &quot; + this.greeting; &#125;&#125;let greeter: Greeter;greeter = new Greeter(&quot;world&quot;);console.log(greeter.greet()); 创建了一个构造函数，会在new创建实例的时候调用。 上面的代码被编译之后： 12345678910111213let Greeter = (function () &#123; function Greeter(message) &#123; this.greeting = message; &#125; Greeter.prototype.greet = function () &#123; return &quot;Hello, &quot; + this.greeting; &#125;; return Greeter;&#125;)();let greeter;greeter = new Greeter(&quot;world&quot;);console.log(greeter.greet()); 回顾：使用new函数会发生什么？ 创建一个空对象，成为newInstance（新的实例） 如果构造函数的prototype是一个对象，那么把newInstance的原型指向prototype，否则newInstance为一个普通对象，原型为Object.prototype 使用给定参数执行构造函数，并把newInstance绑定为this上下文 如果构造函数返回非原始值，则返回值为new的结果，否则返回newInstance 函数类型推断： 123// The parameters `x` and `y` have the type numberlet myAdd: (baseValue: number, increment: number) =&gt; number = function(x, y) &#123; return x + y; &#125;; x 和 y会被自动推断为 number类型 可选参数和默认参数 使用 ？修饰 比如 name?:string 可选参数必须放到默认参数之后 剩余参数 123function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);&#125; 重载123456789101112131415function pickCard(x: &#123;suit: string; card: number; &#125;[]): number;function pickCard(x: number): &#123;suit: string; card: number; &#125;;function pickCard(x:any): any &#123; // Check to see if we&#x27;re working with an object/array // if so, they gave us the deck and we&#x27;ll pick the card if (typeof x == &quot;object&quot;) &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == &quot;number&quot;) &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125; 被重载的函数不能声明方法体 只有一个方法可以声明方法体，并且重复的入参必须为any 它按照顺序查找重载列表，尝试使用第一个满足的定义。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。 泛型123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 使用尖括号定义 意义：arg的类型和identity函数返回的值的类型一样 1234function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); // Array has a .length, so no more error return arg;&#125; 泛型参数名只要在数量上和使用方式上能对应就行 泛型类12345678class Person&lt;T&gt;&#123;\tzeroValue: T;\tname:T;&#125;let liu = new Person&lt;string&gt;();liu.name=&quot;asdf&quot;liu.zeroValue=&quot;adfa&quot; 类有两部分，静态部分和实例部分，泛型指的是实例部分的类型 泛型约束12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // Now we know it has a .length property, so no more error return arg;&#125; 如果我们想获得arg的长度，可以让泛型T继承一个带有length属性的接口 如果T为number会报错，string则不会 或者 123loggingIdentity&lt;string&gt;(&#x27;hello&#x27;)loggingIdentity&lt;number&gt;(234) //报错loggingIdentity(&#123;length: 10&#125;) 在泛型里使用类类型123function create&lt;T&gt;(c: &#123;new(): T; &#125;): T &#123; return new c();&#125; 在此处，new（）代表一个无参的构造函数 所以此处的入参c的意义为：一个含有无参的构造函数的对象 1234567891011121314//***类型标注***，表示一个没有参数的构造函数。function create&lt;T&gt;(c: &#123;new(): T; &#125;): T &#123; console.log(c) return new c();&#125;class Anim &#123; constructor() &#123;&#125; // constructor(name:string) &#123;&#125; 则会报错&#125;console.log(create(Anim) instanceof Anim); //true//create(Anim)会创造一个animal对象 小思考题 枚举数字枚举12345678910111213enum Animal &#123; Cat = 2, Dog, //3 Rabbit=6, Lion //7&#125;console.log(Animal.Cat === 2)enum E &#123; A = getSomeValue(), B, // error! &#x27;A&#x27; is not constant-initialized, so &#x27;B&#x27; needs an initializer&#125; 索引从0开始，下面的比上面的增加1 如果某一个成员不是constant值，那么下面的成员必须初始化 字符串枚举即使用字符串进行初始化 1234567enum Animal &#123; Cat = &quot;Cat&quot;, Dog = &quot;Dog1&quot;,&#125;console.log(Animal.Cat) // Cat 没有自增长行为，可以序列化 异构即数字、字符串混合，不建议 联合枚举与枚举成员的类型1234567891011121314151617181920enum ShapeKind &#123; Circle, Square,&#125;interface Circle &#123; kind: ShapeKind.Circle; radius: number;&#125;interface Square &#123; kind: ShapeKind.Square; sideLength: number;&#125;let c: Circle = &#123; kind: ShapeKind.Square, // ~~~~~~~~~~~~~~~~ Error! radius: 100,&#125; 枚举成员成为了类型，意义为：这里Circle接口的kind只能为ShapeKind.Circle类型 枚举类型成为了枚举成员的类型联合 ★★反向映射★★12345enum Enum &#123; A&#125;let a = Enum.A;let nameOfA = Enum[a]; // &quot;A&quot; ★★可能会将编译为★★ 123456var Enum;(function (Enum) &#123; Enum[Enum[&quot;A&quot;] = 0] = &quot;A&quot;;&#125;)(Enum || (Enum = &#123;&#125;));var a = Enum.A;var nameOfA = Enum[a]; // &quot;A&quot; 或许添加两个输出会更加直观 12345678var Enum;(function (Enum) &#123; Enum[Enum[&quot;A&quot;] = 0] = &quot;A&quot;;&#125;)(Enum || (Enum = &#123;&#125;));var a = Enum.A;var nameOfA = Enum[a]; // &quot;A&quot;console.log(Enum[0]) //Aconsole.log(Enum[&quot;A&quot;]) //0 枚举类型被编译为一个Enum对象，包含了正向name→value 和反向映射 value → name , 不会为字符串枚举成员生成反向映射 例子： 12345678enum Enum &#123; A = 1, B, C = 2&#125;console.log(Enum.B === Enum.C) // trueconsole.log(Enum[2]) // C 过程 生成一个Enum对象 设置A的正向映射为1，同时设置1的反向映射为A 设置B的正向映射为2，同时设置2的反向映射为B 设置C的正向映射为2，同时设置2的反向映射为C，覆盖了原来的B 12345(function (Enum) &#123; Enum[Enum[&quot;A&quot;] = 1] = &quot;A&quot; Enum[Enum[&quot;B&quot;] = 2] = &quot;B&quot; Enum[Enum[&quot;C&quot;] = 2] = &quot;C&quot;&#125;(Enum || (Enum = &#123;&#125;))) 类型推论最佳通用类型12let x = [0, 1, null];x : (number|null)[] 12let zoo = [new Rhino(), new Elephant(), new Snake()];(Rhino | Elephant | Snake)[] 上下文类型123window.onmousedown = function(mouseEvent) &#123; console.log(mouseEvent.button); //&lt;- Error&#125;; 根据上文的window.onmousedown推断出mouseEvent的类型为MouseEvent 1mouseEvent:any 使用注解抵消上下文类恶行 类型兼容性 如果x要兼容y，y至少具有与x相同的属性 12345678interface Named &#123; name: string;&#125;let x: Named;// y&#x27;s inferred type is &#123; name: string; location: string; &#125;let y = &#123; name: &#x27;Alice&#x27;, location: &#x27;Seattle&#x27; &#125;;x = y; 过程：编译器递归检查x中的每个属性，看是否在y中能找到属性名一样且类型相同的属性 比较两个函数12345let x = (a: number) =&gt; 0;let y = (b: number, s: string) =&gt; 0;y = x; // OKx = y; // Error 理解 y赋值给x可以，因为同时传递b和s之后，b的值可以赋值给a，也满足x的条件 x赋值给y不行，因为只传递a之后，无值可用 编译时不会赋值尝试，只会根据类型进行判断 12345let x = () =&gt; (&#123;name: &#x27;Alice&#x27;&#125;);let y = () =&gt; (&#123;name: &#x27;Alice&#x27;, location: &#x27;Seattle&#x27;&#125;);x = y; // OKy = x; // Error, because x() lacks a location property 把y赋值给x那么参数依然可以调用name(x中所有的值 源函数的返回值类型必须是目标函数返回值类型的子类型 函数参数双向协变123456789101112131415161718192021222324enum EventType &#123; Mouse, Keyboard &#125;interface Event &#123; timestamp: number;&#125;interface MouseEvent extends Event &#123; // @ts-ignore x: number // @ts-ignore y: number&#125;function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) &#123; /* ... */&#125;// 1listenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x + &#x27;,&#x27; + e.y));// 2listenEvent(EventType.Mouse, (e: Event) =&gt; console.log((&lt;MouseEvent&gt;e).x + &#x27;,&#x27; + (&lt;MouseEvent&gt;e).y));listenEvent(EventType.Mouse, &lt;(e: Event) =&gt; void&gt;((e: MouseEvent) =&gt; console.log(e.x + &#x27;,&#x27; + e.y))); 1处报错，因为MouseEvent是Event的衍生类，不能“覆盖”Event 可以传入Event，之后使用 as 或者 &lt;&gt; 显示判断类型 可选参数和剩余参数 可选参数 ?. ，剩余参数 …args 可选参数可以当作无限个可选参数 123456789function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123; /* ... Invoke callback with &#x27;args&#x27; ... */&#125;// Unsound - invokeLater &quot;might&quot; provide any number of argumentsinvokeLater([1, 2], (x, y) =&gt; console.log(x + &#x27;, &#x27; + y));// Confusing (x and y are actually required) and undiscoverableinvokeLater([1, 2], (x?, y?) =&gt; console.log(x + &#x27;, &#x27; + y)); 此时，args为x,y…. 高级类型交叉类型 多个类型合并为一个类型 Person &amp; Serializable &amp; Loggable ,同时有这三种类型的成员 123456789101112function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125; 联合类型 表示可以是几个类型之一 number | boolean | string 表示可以是这三个类型之一 如果一个值是联合类型，只能访问共有的成员 12345678910111213interface Bird &#123;\tmove()\tdance()\t&#125; interface Fish &#123; move() eat()\t&#125;\tlet ani: Bird | Fishani.move()ani.dance() //wrong 类型保护和区分类型使用联合类型时用来区分不同类型 类型断言 12345678let pet = getSmallPet();if ((&lt;Fish&gt;pet).swim) &#123; (&lt;Fish&gt;pet).swim();&#125;else &#123; (&lt;Bird&gt;pet).fly();&#125; 类型保护 1234567function isFish(pet: Fish | Bird): pet is Fish &#123; return (&lt;Fish&gt;pet).swim !== undefined;&#125;if(isFish(pet))&#123;\tpet.swim();&#125; pet is Fish ：类型谓词 这样可以判断在if分支中一定是Fish类型 typeof、instanceof 可选参数和可选属性 使用了—strictNullChecks 可选参数会自动加上 | undefined 1234567function f(x: number, y?: number) &#123; return x + (y || 0);&#125;f(1, 2);f(1);f(1, undefined);f(1, null); // error, &#x27;null&#x27; is not assignable to &#x27;number | undefined&#x27; 类型别名给类型起一个新的名字 1type Name = string; 不会新建一个类型 创建了一个新的名字来引用那个类型 接口类型可以是泛型 1type Container&lt;T&gt; = &#123; value: T &#125;; 在属性里引用自己 12345type Tree&lt;T&gt; = &#123; value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;;&#125; ☆☆接口和类型别名☆☆interface和type 接口创建了一个新的名字，可以在其他地方使用，类型别名不创建新的名字，而是类型的引用 类型别名不能被或者extends、implements其他类型，interface对于拓展是开放的 多个同名的interface会合并（相同属性声明为不同类型时候会报错），type则会报错 type可以表示联合类型和交叉类型，interface则会报错 12type Animal = &quot;fish&quot; | &quot;cow&quot;interface Animal = &quot;fish&quot; | &quot;cow&quot; //报错 type 可以表示元组、枚举、基本类型（如 string、number、boolean）、字面量类型等，而 interface 不能。 可辨识类型1234567891011121314151617181920212223242526interface Square &#123; kind: &quot;square&quot;; size: number;&#125;interface Rectangle &#123; kind: &quot;rectangle&quot;; width: number; height: number;&#125;interface Circle &#123; kind: &quot;circle&quot;; radius: number;&#125;interface Triangle &#123; kind: &quot;triangle&quot;; width: number&#125;type Shape = Square | Rectangle | Circle | Triangle;function area(s: Shape) &#123; switch (s.kind) &#123; case &quot;square&quot;: return s.size * s.size; case &quot;rectangle&quot;: return s.height * s.width; case &quot;circle&quot;: return Math.PI * s.radius ** 2; default : return assertNever(s) //检查是否是Never &#125;&#125; 索引类型让编译器可以检查使用了动态属性名的代码 12345interface Person &#123; name?: string&#125;let personProps: keyof Person = &quot;age&quot; personProps是Person中的一个属性, type、interface、class都可以使用 映射类型123456type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P];&#125; ///把T中所有的类型变为只读的type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125; ///把T中所有的类型变为可选的 keyof T表示T中所有属性名的联合类型 P in keyof T 类型映射，遍历T的所有属性名，为每个属性名P创建一个新的类型 T[P] 表示属性P在T中的类型 readonly 表示这个属性是只读的 Symbol一些内置的Symbol： Symbol.hasIntance 会被instanceof运算符调用，构造器对象用来识别一个对象是否是实例 12345678class MyObject &#123; static [Symbol.hasInstance](instance) &#123; return Array.isArray(instance); &#125;&#125;console.log([] instanceof MyObject); // 输出：trueconsole.log(&#123;&#125; instanceof MyObject); // 输出：false Symbol.iterator 12345678class MyObject &#123; static [Symbol.hasInstance](instance) &#123; return Array.isArray(instance); &#125;&#125;console.log([] instanceof MyObject); // 输出：trueconsole.log(&#123;&#125; instanceof MyObject); // 输出：false Symbol.toPrimitive 1被ToPrimitive抽象调用，对象转化为相应的原始值 声明合并编译器将针对同一个名字的两个独立生命合并为单一声明 ts声明会创建：命名空间、类型、值。 接口 非函数成员应该是唯一的 同名函数会被当成重载，在后面声明的接口优先级更高（出现在靠前的位置） 出现特殊的函数签名的时候，即，有一个参数是单一的字符串字面量，会被提升到最顶端 命名空间12345678910111213141516namespace Animals &#123; export class Zebra &#123; &#125;&#125;namespace Animals &#123; export interface Legged &#123; numberOfLegs: number; &#125; export class Dog &#123; &#125;&#125;///等价于namespace Animals &#123; export interface Legged &#123; numberOfLegs: number; &#125; export class Zebra &#123; &#125; export class Dog &#123; &#125;&#125; 模块扩展12345678910// observable.jsexport class Observable&lt;T&gt; &#123; // ... implementation left as an exercise for the reader ...&#125;// map.jsimport &#123; Observable &#125; from &quot;./observable&quot;;Observable.prototype.map = function (f) &#123; // ... another exercise for the reader&#125; 编译器不会进行提示，通知编译器： 1234567891011121314151617// observable.ts stays the same// map.tsimport &#123; Observable &#125; from &quot;./observable&quot;;declare module &quot;./observable&quot; &#123; interface Observable&lt;T&gt; &#123; map&lt;U&gt;(f: (x: T) =&gt; U): Observable&lt;U&gt;; &#125;&#125;Observable.prototype.map = function (f) &#123; // ... another exercise for the reader&#125;// consumer.tsimport &#123; Observable &#125; from &quot;./observable&quot;;import &quot;./map&quot;;let o: Observable&lt;number&gt;;o.map(x =&gt; x.toFixed());","tags":["本手"],"categories":["TypeScript"]},{"title":"OAuth2.0与SSO：打造一个属于懒蛋的世界","path":"/2024/08/01/11oauth2-sso/","content":"试想一下，你是一个懒蛋，你不想记住各种各样的账号密码，你不想在各种网站上注册账号，你只想使用一个账号密码，然后就可以访问所有的网站，这个时候，OAuth2.0和SSO就是你的救星。 OAuth2.0 请看上图的最下方，有许多用其他方式登录的选项，这就是OAuth2的应用场景 点击微信登录之后 那么，西窗烛是怎么和微信的用户信息进行关联的呢？ 第一步，用户登录时需要选择登录方式，西窗烛确认用户登录方式后，返回一个uri跳转到对应的授权界面第二步，用户选择对应的登录用户，同意授权第三步，西窗烛告诉微信 “用户要使用你的资源，快给我” ，微信Auth服务返回一个Access Token给西窗烛最后一步，西窗烛 使用Access Token向微信（Resource）资源服务请求对应用户的信息 大概流程就是这样，我们下期再见… 等等！你也发现了，上面的流程漏洞百出对不对？别急，我已经预判到了你的想法，让我们慢慢讲 西窗烛告诉微信要资源他就给，万一是一个恶意软件呢？首先，能够实现微信登录的应用都是经过微信审核认证通过的，微信会给审核通过的应用一个Secret Id 和Secret Key，应用索要用户信息时需要携带这两个键，用于告诉微信 “是谁在向你要信息” 就像是一个房子，只有拥有钥匙的客人才能够进去使用 如果是一个伪装成好的软件的恶意软件，用户没同意也说他同意了怎么办 ？这也不需要着急，还记得我们说的第一步吗，西窗烛返回一个uri，然后用户的会跳转到对应uri的界面，在这里是微信界面，事实上，此时，用户就已经进入到微信所能掌控的领域了，而并不是西窗烛，用户根据微信提供的授权界面进行授权换句话说，这个操作是在 _微信_ 进行的！ 好好好算你厉害，最后一个问题，应用如果使用Access Token随意获取用户信息怎么办（冷笑）？你先冷静，我猜你的问题是应用申请完一个用户的Access Token，但是用这个用户的Access Token请求其他用户的信息怎么办，对不对？这位同志，我建议你先去看一下JWT，Token中是包含目标用户id、以及有效时间的不仅能够防止不同用户的Access Token隔离也能防止一个Access Token请求多次 既然这位同志没有问题了，那么我们开始介绍SSO单点登录 SSO单点登录SSO单点登录，是指用户只需要登录一次（通过一个专门的服务提供商），就可以访问所有的应用，而不需要再次登录那有人就会问了，这不就是OAuth2吗？还是那句话：别急，我们往下看! 还是那句话，先上图！ 很乱，看不懂，对吧？我们慢慢来 首先我们设想现在有一个用户，叫user1，然后服务提供商叫做identity provider，有两个应用，分别叫做app1和app2 用户登陆时， 用户访问app1，app1发现用户没有登录，返回一个SAR（Service Authorization Request）给浏览器 用户根据返回的SAR，跳转到SAR指定的identity provider的登录界面 identity provider给用户展示一个登录界面，用户正常登录 用户登录之后，identity provider返回一个SAML给用户 用户拿着SAML，跳转到app1的界面，app1进行验证（公钥私钥） 验证通过，app1允许用户登录 这里面有几个专业名词，稍微解释一下: SAML：Security Assertion Markup Language，安全断言标记语言，是一种基于XML的标准，用于在不同的安全域之间传递身份验证和授权数据简单的来说，在这个场景中，就是一个包含有用户信息的、加密的XML文件 SAR：SAML Authorization Request, SAML授权请求 identity provider：身份提供商，负责用户的认证和授权 当用户第二次登录时： 用户访问app2, app2也会返回一个SAR给浏览器 浏览器根据SAR跳转到identity provider的登录界面，此时，identity provider会发现用户已经登录过了，直接返回SAML给用户 用户拿着SAML，跳转到app2的界面，app2进行验证 这就是SSO单点登录的大致流程，当然，实际上，还有很多细节需要处理，比如SAML的加密解密，SAML的有效时间等等 OAuth2.0与SSO的区别简单的来说， OAuth2.0是一种授权协议，SSO是一种登录方式OAuth2主要用于不同团体的应用，而SSO主要用于同一个团体，比如公司内部的应用 OAuth2主要用于授权一些平台账号的资源，比如头像、用户名之类的，“平台”有自己专门的功能， SSO主要用于公司内部的应用，而identity provider就是公司的统一认证中心，专门负责用户的认证和授权 Casdoor：一个开源的SSO单点登录系统，可以用于公司内部的应用","tags":["本手","develop"]},{"title":"HTTP 驾驭网络的艺术","path":"/2024/07/25/10http/","content":"在开始之前，明确几个概念：HTTP 即 “超文本传输层协议”协议是指计算机之间通信的规则的集合，这些规则是**约定俗称**的。超文本，HTML，是http设置之初的传输目标 本文将会以HTTP的历史为主线，讲述不同版本之间的差异，以及不同版本的新特性。 概述HTTP分为三个版本：HTTP&#x2F;0.9,HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2.0，HTTP&#x2F;3.0 HTTP&#x2F;0.9HTTP&#x2F;0.9是HTTP的第一个版本，它是一个极简的协议只有一个命令GET，没有HEADER等描述数据的信息，服务器发送完毕数据之后就关闭TCP连接。 他的报文只有一行，如下： 1GET /index.html HTTP&#x2F;1.0 随着每个请求发送协议版本信息，原来第一行只有 方法+路径，现在变成了 方法+路径+协议版本 服务端会发送状态码，使客户端可以更灵活的处理请求 新增了一些请求方法，POST、HEAD 引入了HTTP Header，具备了传输纯文本HTML以外的能力 以下是HTTP&#x2F;1.0的报文格式： 1234567891011GET /mypage.html HTTP/1.0User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)200 OKDate: Tue, 15 Nov 1994 08:12:31 GMTServer: CERN/3.0 libwww/2.17Content-Type: text/html&lt;HTML&gt;一个包含图片的页面 &lt;IMG SRC=&quot;/myimage.gif&quot;&gt;&lt;/HTML&gt; Content-Type 示例 12Content-Type: text/gif(这里是图片内容) User-Agent: 告诉服务器客户端的类型和版本信息，服务端可以因此返回不同的资源，可以用于解决浏览器兼容性问题 Server:用于告诉客户端服务器的类型和版本信息 Content-Type: 用于告诉客户端返回的资源类型，如果存在，浏览器将不考虑文件类型完全按照这个字段解析，如果不存在，则由浏览器自主判断 Body: 服务器返回的资源 HTTP&#x2F;1.1HTTP&#x2F;1.0是HTTP的第一个正式版本，它的特点是： 连接可以复用，节省了多次打开TCP连接的时间 增加管线化技术，实现流水线、并发两种请求方式 增加了PUT、DELETE、TRACE、OPTIONS等方法 增加了状态码 引入内容协商机制，客户端和服务器交换最合适的内容 1234567891011121314151617181920GET /zh-CN/docs/Glossary/CORS-safelisted_request_header HTTP/1.1Host: developer.mozilla.orgUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.9Accept-Encoding: gzip, deflate, brReferer: https://developer.mozilla.org/zh-CN/docs/Glossary/CORS-safelisted_request_header200 OKConnection: Keep-AliveContent-Encoding: gzipContent-Type: text/html; charset=utf-8Date: Wed, 20 Jul 2016 10:55:30 GMTKeep-Alive: timeout=5, max=1000Etag: &quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;Last-Modified: Tue, 19 Jul 2016 00:59:33 GMTServer: ApacheTransfer-Encoding: chunkedVary: Cookie, Accept-Encoding 可以看到，新增加了几个字段 Accept: 告诉服务器客户端接受的资源类型 Accept-Language: 告诉服务器客户端接受的语言 Accept-Encoding: 告诉服务器客户端接受的编码方式 Referer: 告诉服务器客户端请求的来源,允许服务器生成回退链接，用于日志记录等，但是可能会带来隐私问题，Referrer-Policy可以控制这个字段的发送 Content-Encoding: 告诉客户端返回的资源的编码方式 Etag: 用于缓存控制 Last-Modified: 用于缓存控制 Transfer-Encoding: chunked，告诉客户端返回的资源是分块传输的 Vary: Cookie, Accept-Encoding，告诉客户端服务器根据这两个字段来生成缓存 Connection: Keep-Alive，告诉服务器客户端是否支持长连接，即保持TCP连接 Keep-Alive: timeout&#x3D;5, max&#x3D;1000，告诉客户端服务器保持连接的时间和最大连接数 Server: Apache，告诉客户端服务器的类型和版本信息 特性在这个版本里，增加了许多字段,这些字段可以让客户端和服务器更好的交互，提高了HTTP的性能 TCP连接复用相关字段： Connection: Keep-Alive，告诉服务器客户端是否支持长连接，即保持TCP连接 Keep-Alive: timeout&#x3D;5, max&#x3D;1000，告诉客户端服务器保持连接的时间和最大连接数 在HTTP1.0以及其以前，发送一个HTTP请求需要建立一个TCP连接，信息发送之后，立即关闭连接，这样的方式效率很低，因为TCP连接的建立和关闭都需要时间，而且每次建立连接都需要三次握手。所以HTTP1.1引入了长连接，即在一个TCP连接上可以发送多个HTTP请求，这样就可以节省大量的时间。 HTTP缓存强缓存 浏览器不会向服务器发送请求，直接从缓存中读取资源 Expires: Tue, 19 Jul 2016 00:59:33 GMT Cache-Control: max-age&#x3D;3600 在HTTP 1.0时，使用是Expires字段，告诉客户端资源的过期时间但是时间格式难以解析，也发现了很多实现的错误，有可能通过故意偏移系统时钟来诱发问题 在HTTP 1.1时，引入了Cache-Control字段，可以更加灵活的控制缓存策略,如max-age&#x3D;3600，表示资源在3600秒内有效 上文提到，直接从缓存中读取资源，这里的缓存是指浏览器的缓存初次请求时，浏览器会将资源缓存到本地，下次请求时，浏览器会判断是否有**名称相同**的资源，如果有，直接从本地读取，不会向服务器发送请求 比如第一次请求一个index.html，浏览器会将这个资源缓存到本地，下次请求时，浏览器会判断是否有index.html这个资源，如果有，直接从本地读取 拓展：为什么在本地开发原生html的时候需要保存一下才能显示最新的界面？ 因为浏览器会缓存html页面，保存一下是为了更改html资源的hash值,这样才能显示最新的界面 协商缓存两种方法 Etag + If-None-Match 第一次请求时，设置Etag 第二次请求时，随If-None-Match字段发送Etag，服务器根据Etag判断资源是否更新，如果没有更新，返回304，否则返回200 Last-Modified + If-Modified-Since 第一次请求时，设置Last-Modified 第二次请求时，随If-Modified-Since字段发送Last-Modified，服务器根据Last-Modified判断资源是否更新，如果没有更新，返回304，否则返回200 HTTP&#x2F;2.0特点： 由原来的文本协议变成了二进制协议，即，不在可读 多路复用，一个TCP连接上可以同时发送多个请求 首部压缩，减少了首部的大小 HTTPS HTTPS是HTTP的安全版本，它是在HTTP的基础上加入了SSL或者TLS协议，用于加密数据传输 SSL是TSL的前身 TSL加密过程 客户端向服务器发送一个请求，请求建立一个安全连接,同时发送TSL版本，以及生成并发送第一个随机数 （此时，客户端拥有第一随机数，服务端拥有第一随机数） 服务端收到请求，向客户端发送一个证书，证书中包含了服务端的公钥，以及生成并发送第二个随机数（客户端拥有公钥、第一随机数，第二随机数，服务端拥有公钥、私钥、第一随机数，第二随机数) 客户端生成一个预主密钥，并使用公钥加密，之后发送到服务端，服务端用私钥解密（此时，客户端拥有公钥、第一随机数，第二随机数、预主密钥，服务端拥有公钥、私钥、第一随机数，第二随机数,预主密钥) 之后，服务端和客户端分别用第一随机数、第二随机数、预主密钥计算出会话密钥 之后，开始通信 这样具体在哪些方面比较安全？ 信息是加密的，即人类无法阅读 客户端全程不接触用来解密的私钥，防止了客户端离谱的操作带来的问题 会话密钥生成过程中完全没有经过网络传输 公钥私钥加密解密示例 公钥 (17, 3233) 私钥 (275, 3233) 加密过程 明文 72 密文 72^17 % 3233 &#x3D; 2201 解密过程 密文 2201 明文 2201^275 % 3233 &#x3D; 72 注意： 这只是一个简单的示例，攻击者可以通过密文、公钥爆破解出原来的明文。但是!由于爆破过程中可以产生多个结果，所以，爆破者无法确定哪个是正确的明文!再但是，由于计算机的计算能力，爆破者可以通过多次尝试，找到正确的明文 为了防止这种情况，真实的情况可以通过增加密文长度，增加公钥私钥长度，增加计算量，来增加破解难度 比如RSA加密"},{"title":"从Flutter到React,架空用户的性能宰相","path":"/2024/07/20/9flutter-react/","content":"“彼时彼刻，恰如此时此刻”“竟能如此相像？” ————题记 渲染基本原理本部分权当科普,亦欲抛砖引玉 计算机图像中的渲染需要三个部分配合CPU、GPU、显示器其中，CPU负责图像数据计算、GPU负责图像数据渲染、显示器负责图像数据显示CPU把计算好的、需要显示的内容交给GPU，由GPU完成渲染后放入帧缓冲区，随后视频控制器根据垂直同步信号（VSync）以每秒60次的速度，从帧缓冲区读取帧数据交由显示器完成图像显示。 CPU:任务调度、数据计算GPU：图像渲染、着色器、抗锯齿、光栅化等载体：包括浏览器、App等 How Flutter Work ?这个问题可以从两个方面回答，第一个是 用什么 , 第二个是 怎么用从 用什么 的角度，Flutter团队使用了两个工具，一个是dart，一个是skia从 怎么用 的角度，Flutter团队使用了三棵树，分别是Widget Tree、Element Tree、RenderObject Tree Dart and Skia此处我们简单掠过，并不是本文的重点 1.Skia是一款用C++开发的2D图像绘制引擎，保证了同一套代码调用在多个平台上的渲染效果是完全一致的。 2.Dart是一个前端开发的强类型语言。 Flutter RenderFlutter 的三棵树1.Widget Tree2.Element Tree3.RenderObject Tree 那么Widget、Element、RenderObject指的是什么呢？ Widget: 是Flutter的基本构建块，是一个不可变的配置信息比如一个Container组件，有什么子元素？背景颜色是什么？宽高啊等等 在flutter中，Everything is a Widget A widget is immutable description of part a user interface 一个Widget是一个不可变的用户界面的描述 当然，如果你学过html，可以先把Widget理解为html中的标签，比如div、span等等，即dom但是显然会有以下问题：既然widget不可变，那么Flutter是如何更改UI(用户界面)的呢？这就引出了Element和RenderObject的概念 Element 是Widget的实例，是可变的，当我们当我们用一个新的Widget替换旧的Widget时，Element会更新其属性甚至新建新的Element以匹配新的Widget。 RenderObject是Element的一个实例，它也是可变的。RenderObject包含了实际的绘制操作，它描述了在屏幕上显示的内容。简单的来说，RenderObject就是Flutter “需要绘制出的东西” Flutter Render Steps以如下代码为例 123runApp( Text(&quot;Hello World&quot;)&#125; 在这个例子里，flutter新建了一个Text： 运行runApp，并把Text放到Widget树中, 创建一个LeafRenderObjectElement(ps1:这里是Element，不是RenderObject! ; ps2:Leaf表示这是一个叶子节点，即没有子节点的节点) 根据LeafRenderObjectElement的creatRenderObject创建一个RenderObject,即RenderParagraph 不过需要注意的是： Flutter不会为每个Widget都创建一个RenderObject，而是经过层层调用之后的叶子元素才会创建RenderObject 比如，Text这个Widget内部是由RichWidget实现的，Flutter的Widget树会有Text-RichText树结构，但是并不会为Text创建一个RenderObject，而是RichText创建一个RenderObject(此处为了方便理解，使用最常见的Text，并且暂且无视RichText) 当Flutter更新的时候，以图中为例，我们把Text展示的文字从Hello 改为HiFlutter将会做以下几件事： 创建一个新的Text Widget，并使用canUpdate方法把他和之前的Widget比较 canUpdate传入oldWidget 和 newWidget，返回true或false，可以和react 的shouldComponentUpdate比较 如果不同，则替换原有的Widget 此时,LeafRenderObjectElement,则需要改变，会调用updateRenderObject方法 与创建不同的是，这里的LeafRenderObjectElement会获取已有的RenderObject并改变其状态，而非新建、替换 如果你使用flutter开发工具来查看RenderObject id，会发现并没有改变 由于不太好对比，略去相同的情况的图 可以看到，当使用RichText和Text的时候，两者切换时，RenderObjectId会改变至于为什么使用Text时，也存在RichText的树级结构，是因为Text内部是由RichText加工得到的 由此可以验证上文,Flutter不会为每个Widget都创建一个RenderObject，而是经过层层调用之后的叶子元素才会创建RenderObject 在开始React部分之前，我们先来看一道老生常谈的八股题事实上，虽然称之为“八股”，但我认为这道题很真的很有意义 讲一下浏览器的渲染流程 ?从网络拿到html文件之后，开启渲染主线程进行解析，目的是解析为DOM树同时开启一个预加载线程，这个线程主要负责css资源, 预加载线程快速浏览Link部分，通过网络线程请求css资源，之后在预加载线程进行解析并且返回给渲染在主线程。（解析、计算样式）在遇到html中的js文件时，会停止html解析，即阻塞主线程 渲染主线程获得DOM树以及CSSOM树之后，会进行计算样式，把预设样式转化为对应的值以及相对样式转化为绝对样式。（布局） 主线程遍历合成之后的树，生成布局树。之后对布局树进行分层，这一部分是为了更改时更快。（分层） 主线程为每个层生成单独的指令集。（生成指令集） 至此主线程任务结束。 之后进行分块，会把上一步的指令集会交给合成线程，合成线程的工作会交给多个线程进行。（分块） 合成线程把信息、任务交给GPU进程，GPU开启多个线程，进行进行光栅化，并且优先处理靠近视口区域的块，即进行计算每个像素点的颜色。（光栅化） 之后，GPU把每个层、块的光栅化结果交给合成线程，合成线程计算出每个块的位置，以及旋转、缩放等。（合成） Ok,我们现在进入React部分 How React Renders ?What is React ?什么是React？ 这里需要简单祛魅一下，React是一个library是一个库，不是一个framework.如果需要类比的话，类似于lodash、tinyColor等等 但是为什么React如此如日中天，被推崇备至？因为React的这两个核心特性：声明式API、虚拟Dom 不过，如果深入理解一下的话，你会发现声明式API和虚拟Dom是双生一体，无法分割的两个特性 声明式API所谓的声明式API，就是告诉React你想要的是什么，而并非是如何做。 举个例子，我们现在有一个列表,列表包括两个div，一个是红色，一个是蓝色 123&lt;div id=&quot;1&quot; style=&quot;color:red&quot;&gt;Red&lt;/div&gt;&lt;div id=&quot;2&quot; style=&quot;color:blue&quot;&gt;Blue&lt;/div&gt; 现在有一个需求，需要你把Blue的div变成红色，这时候在html、js中的操作是什么呢？ 1document.getElementById(&#x27;2&#x27;).style.color = &#x27;red&#x27; 这样的操作是命令式的，即告诉你的工具如何做那么声明式的操作是什么? 12345 const [color, setColor] = useState(&#x27;blue&#x27;)&lt;div id=&quot;1&quot; style=&#123;&#123;color: &#x27;red&#x27;&#125;&#125;&gt;Red&lt;/div&gt;&lt;div id=&quot;2&quot; style=&#123;&#123;color: color&#125;&#125;&gt;Blue&lt;/div&gt; 当我们想要操作的时候，只需要改变color的值即可，React会自动帮你完成剩下的操作 当然，这个例子并没有完全显示出声明式API的优越性，但是当你的项目越来越大，你会发现声明式API的优势 虚拟Dom所谓虚拟DOM，是一种概念大致就是在内存中创建一个虚拟的DOM树，当数据发生变化时，React会比较新旧两颗虚拟DOM树的差异，然后只更新差异部分。 分为 diff 和 调和 两个部分diff：找出current 虚拟dom 和 next 虚拟dom 的差异调和：让真实dom树和current虚拟dom树保持一致 Diff AlgorithmReact 的 Diff 算法主要基于两个假设：两个不同类型的元素会产生不同的树。开发者可以通过 key 属性来指示哪些子元素在不同的渲染下能保持稳定。基于这两个假设，React 的 Diff 算法可以被分为两个主要部分：元素类型的比较和同一类型元素的比较。元素类型的比较 当 React 对比两个元素时，首先会检查元素的类型。如果元素的类型不同，React 会直接销毁旧的树并建立新的树。例如，当一个元素从 a 变为 img，React 会销毁 a 及其子元素，然后新建 img 及其子元素。 同一类型元素的比较 当两个元素为同一类型时，React 会保留 DOM 节点，并仅比较和更新改变的属性。然后，React 会递归地对子元素进行相同的过程。 对于列表元素，React 无法知道列表中的元素是否有变化，因此需要开发者提供一个 key 属性来帮助 React 识别哪些元素是新的，哪些元素是旧的。这样，React 就可以只更新改变的元素，而不是重新渲染整个列表。总的来说，React 的 Diff 算法通过智能地比较新旧虚拟 DOM 树的差异，使得只有实际改变的部分才会被更新，从而提高了性能。 使用了深度优先的遍历算法 优化策略 忽略了跨层级的节点的比较 通过 key 来判断是否是同一个节点 为什么使用深度优先？ 假设有以上dom树，两层，每个非叶子节点都有n个子节点 对于n1点，广度优先：遍历n+1个节点深度优先：遍历2个节点 对于n2点，广度优先：遍历2n个节点深度优先：遍历1+n个节点 对于n3点，广度优先：遍历n+n×n个节点深度优先：遍历n+n×n个节点 可见对于叶子节点的改变的比较，深度优先效率要远远大于广度优先 不仅如此，由于：一段时间内大部分的改变都会很集中所以，深度优先更加适合React的Diff算法 Fiber 架构Fiber是虚拟Dom的一种实现方式 在React 16之前，React使用的是Stack Reconciler，即栈调和器，这种调和器是递归的，当递归深度过深时，会导致浏览器卡死Fiber架构是React 16中引入的一种新的协调引擎，它的目的是为了更好地处理虚拟DOM的更新，使其更具有灵活性和效率。 存在内存里的虚拟Dom，需要一种保存格式，Fiber的格式是javascript对象 12345678910&#123; &quot;type&quot;: &#x27;h1&#x27;, // 组件类型 &quot;key&quot;: null, // key &quot;props&quot;: &#123; ... &#125;, // 输入的props &quot;state&quot;: &#123; ... &#125;, // 组件的state (如果是class组件或带有state的function组件) &quot;child&quot;: &quot;Fiber&quot; | &quot;null&quot;, // 第一个子元素的Fiber &quot;sibling&quot;: &quot;Fiber&quot; | &quot;null&quot;, // 下一个兄弟元素的Fiber &quot;return&quot;: &quot;Fiber&quot; | &quot;null&quot;, // 父元素的Fiber&#125; Fiber：一个带有列表关系的DOM树 Fiber工作特性 单元工作：每个Fiber节点代表一个单元，所有Fiber节点共同组成一个Fiber链表 连接属性：slibing 兄弟、child 子节点、return 父节点 React在更新时，会根据现有的Fiber树（Current Tree）创建一个新的临时树（Work-in-progress (WIP) Tree）,WIP-Tree包含了当前更新受影响的最高节点直至其所有子孙节点。因为React在更新时总是维护了两个Fiber树，所以可以随时进行比较、中断或恢复等操作，而且这种机制让React能够同时具备拥有优秀的渲染性能和UI的稳定性。 current 与 workinprogress： react不会改变current tree，而是在workInProgress tree上进行操作，当workInProgress tree完成后，react会将其替换为current tree这里的替换是指针上的替换，即current tree的指针指向workInProgress tree，这样只需要创建两个Fiber树，就可以重复利用，节省了内存 Fiber如何实现优先级?React Fiber的调度器是一个优先级调度器，它可以中断任务，然后根据优先级重新安排任务的执行顺序。这样可以保证高优先级任务的优先执行，从而提高用户体验。 requestIdleCallback 安排低优先级任务 requestAnimationFrame 安排高优先级任务 Fiber工作流程Fiber工作整体分为两个部分 Render Commit 其中，Render部分是异步的，在渲染的过程中可以执行一些网络请求Commit部分是同步的，用于执行副作用 副作用：对于Dom的操作以及特定的生命周期的方法 Render阶段: 创建与标记更新节点 收集副作用列表 在对节点进行遍历时，Fiber采用的是While 循环 而非 递归 的方式 Commit阶段 遍历 Effects 列表并为每个Effect 找到对应的组件实例 正式提交执行副作用 因为Effect 会导致用户可见的界面的改变，所以必须是同步的 回归主题：性能 我们需要明确一个原则：对于视图的改变代价都是高昂的: 在上文 浏览器渲染流程 中我们可以看到，从拿到数据到渲染到屏幕上，需要经过多个步骤，而每个步骤都会消耗时间 Reflow（重排）：当 DOM 的变化影响到元素的几何属性（例如宽度、高度、位置等）时，浏览器需要重新计算元素的几何属性，然后重新渲染页面。这个过程被称为 Reflow。Reflow 主要发生在“计算样式，把预设样式转化为对应的值以及相对样式转化为绝对样式”这个步骤之后，即在“布局”阶段。 Repaint（重绘）：当 DOM 的变化只影响到元素的外观，但并不影响布局时，浏览器只需要重新绘制这些元素。这个过程被称为 Repaint。Repaint 主要发生在“主线程为每个层生成单独的指令集”这个步骤之后，即在“生成指令集”阶段。 DOM的改变的代价要远远大于其样式的改变的代价 所以flutter 和react 都“架空”了用户，给让用户操作“自己的dom”在Flutter中，用户通过widget来实现自己想做的事，在React中，指的是React Component 用户操作之后，Flutter和React，都会生成对应的“虚拟DOM”在Flutter 中，可以简单的理解为Element，而在React中，指的是虚拟DOM（Fiber）并且，在这个过程中进行优化如果Widget可以复用，那么则复用，避免了所有更改。如果不可以，则查看是否可以更新，如果可以更新，则更新，避免了新建的高昂代价。如果不可以，则新建。虚拟DOM（Fiber）也是一样 之前一直在看性能优化的博客，现在才发现是舍本逐末事实上，当我们了解了这些原理之后，性能便手到擒来了 以这篇文章的一些点举两个简单的例子： 因为深度优先的遍历策略，我们尽可能减少dom的嵌套，实现扁平化DOM树 因为React的Diff算法，我们可以使用key来帮助React识别哪些元素是新的，哪些元素是旧的，从而提高性能","tags":["develop","妙手"],"categories":["妙手"]},{"title":"权限认证","path":"/2024/07/14/8Auth/","content":"这两天闲逛掘金，看到了一个19年大火的文章，讲的是token、cookie、session、jwt，和我之前认为的有一些不同去伪留臻，记而存之 附上链接：https://juejin.cn/post/6844904034181070861?searchId=202407022020106665740BE9EADAA2CD66 主要概念： session cookie token jwt json web token oauth2 session和token是一种 ”信息组成“ 的策略 jwt是一种高级协议，解决了token中的一些问题 cookie是一种信息载体，如同localstorage和sessionstorage Oauth2，第三方登录协议 不同概念之间可比较性不高，这也是juejin那篇文章误导性很强的地方之一 存储方式：cookie、localstorage、sessionStoragecookiecookie存储的信息大多被用于： 会话状态管理 用户登陆状态等 个性化设置 自定义设置、主题和其他设置 浏览器行为跟踪 分析用户行为 浏览器第一次请求服务端数据，服务端设置cookie 不过cookie存储空间较小，大约4k localStorage、sessionStorage两者的区别是，sessionStorage只在一次会话中有效 验证信息策略Session浏览器第一次向服务端请求，服务端生成一个seesionid，并储存到内存或者redis或者数据库中，之后，并且把sessionid返回给客户端，此时，可以选择存到cookie中并且不设置过期时间（关闭session清除），也可以放到前端内存（即声明一个全局变量）中（关闭应用清除）。每次请求服务端数据时，服务端检查cookie是否存在sessionid并且进行验证，如果缓存中有sessionid，那么则通过，没有则重新登录 sessionId生成策略：可以是随机数、也可以是客户端传来的数据 特点：存放在服务端，服务端每次收到请求都会查询是否存在sessionid，会给服务端查询造成压力 Token客户端进行登录时，服务端生成一个token（字符串，可以有意义也可以无意义）返回给客户端并由客户端保存，之后每次请求，需要由客户端带上这个token，服务端进行验证 以下是几种token中常用的策略（拓展、变式） 双token，（多用于实现无感登录） 即有两种token，access token 用于请求数据，refresh token 用于刷新access token access token 有效期较短，refresh token 有效时间较长 客户端登录时，服务端生成两个token，access token随请求返回到客户端，用于每次请求时进行验证；refresh token 放到 httponly cookie中，以使客户端无法访问，增加安全性，用于access token过期时进行刷新 JWT 一种 token 的 格式以及包含的信息 的*规范 由三部分组成，头部、中部、尾部, 用.分割，如：xxxxx.yyyyy.zzzzz 头部：加密方式等,使用base64编码 中部：用户的信息，如：用户id等，使用base64编码 尾部：头部和中部结合（简单拼接）后，使用头部声明的加密方式进行加密 客户端进行储存，请求时，只需带上jwt，然后客户端进行解码验证，验证无误则有效，节省存储sessionid的服务器压力，用解码时间换取空间 OAuth2简单的来说，OAuth2也就是第三方认证，比如你想用微信的号登录小红书这个过程，就是OAuth2的过程","tags":["本手"]},{"title":"记录一次开源经历--Ospp","path":"/2024/06/15/6ospp/","content":"之前一直听说开源项目很加分，恰逢最近无事，遂即参与了一个Ospp开源活动的项目需要说明的是，中选公布日期在7月1日，这篇文章作于6.15，所以截至目前为止，我还没有中选，但是我觉得这次经历还是值得记录的 项目介绍项目名叫Casibase，一个企业级Ai提供者: 项目链接: Github链接技术栈:React + Antd 前端 Go后端 项目经历初相见四月半左右我看到了OSPP这个开源活动，很感兴趣而且由于学校安排，小学期有一个实训，只有一个月的实习时间，必然是面试不了，所以我就报名了这个活动 看了大概半个多月的项目列表、每个项目的项目介绍以及难易程度，最终选择了Casibase这个项目其一是因为，技术栈正好对口，React+Go后端，正好符合我的技术栈其二是因为，我觉得相较于单纯的javascript和go项目，这个项目的技术栈更复杂，申请的人数或许也会相对较少 ，阻力可能没那么大。（然而事实证明，并不如我所想并且热门的项目大多是java、linux、ai大模型等等 所以大概在五月初我向导师发送了我的简历,然后导师联系我写了一些pr 主要工作以及收获截至6.15也就是今天，我一共提交了7个pr,合并了6个pr 大致工作有 实现了多模态，即输入消息，实现图片、文本多种回复 仿照tinyColor这个库实现了主题色的自动生成 实现了输入框复制图片 修复了一些bug 虽然和这个导师的交流确实很有压迫力，不过也确实学到了很多东西比如github 的 ci&#x2F;cd流程比如如何写一个好的干净的pr(这一部分被骂了好几次)还有一些git命令(–amend) 另：这也是我第一次看到非函数式react组件，使用的是class之前一直看到生命周期componentDidMount等等，在函数式组件中完全没有，原来是在这里也是我第一次看见把前端项目放到后端项目下的文件夹里算是长知识了( OVER总的来说，这次经历还算不错不过导师跟我说，还有另外一个比较看好的候选人再加上六月末有许多考试，这半个月没法再提交pr所以感觉中选的可能性不大(可恶)","tags":["开源","ospp"]},{"title":"龙芯开发板","path":"/2024/06/15/7long/","content":"正在参与一个实验室的项目我是做前端的，但是后端学长毕业跑路了故而目前软件部分都是我在做 有一部分的工作是,需要写好程序放到这个板子里 也是第一次接触到了开发板这种东西,姑且记录一下之前玩过同学的树莓派，感觉很类似(确实很类似) 总体连接和系统样子： 光是连接这个板子就花了我好长时间，尤其是柔性电路板，我还以为他是个装饰品 而且初始的板子显示比例1080×600无法适配到我的显示器我还以为是显示器和板子不兼容的问题 登录界面 在龙芯vscode上写了一个hello world","tags":["development","记录"]},{"title":"Zing 一款前后端独立gpt软件","path":"/2024/03/23/4Zing/","content":"我常常会想，会不会有一种完美的笔法，能够穷尽此时此刻我所有的想法于一张纸上。于是我便踌躇住，想要捕捉住它。然后，我就会在这种踌躇中，一次次的推迟，直到最后，我发现我已经不再是那个想要写下一篇文章的人了。 Zing 一个GPT软件 概述大致使用的东西： 后端使用的是go语言，前端使用的是flutter。Redis用于邮箱验证码docker用于本地开发验证Linux一些命令 文本聊天使用的模型是GPT-3.5，图片聊天使用的是Stable-diffusion-xl模型 界面功能展示 项目截图logo设计 与 彩色logo其中，黑白logo用于纯文字聊天，彩色logo用于图片 注册登录界面 login and register 主界面 main 聊天界面 chat1.文字聊天演示 text chat2.图片聊天演示 image chat 一些附加1.提供prompts 2.使用prompts 3.版本检查 一些总结总体开发大致持续了十五天左右，从开始学习go到目前以上展示的进度可以称得上是收获颇丰 技术上来讲,这是第一次真正实操了docker、redis、linux、swagger以及一些问题 比之前的纸上谈兵不同 ，实践之后才发现，原来对于我来讲像是一道道关隘的技术概念，真正实操起来也不过尔尔 产品上来讲，这次我是真正体会到了文档的重要性，有组织的开发流程以及预先规定好的字段和接口规范、功能规范，对于开发是真的大有益处心态上来讲，”先完成再优化“，我在开发过程中，一直在想着如何优化，导致进度缓慢 之后会专门写一篇文章来总结一下这次开发的一些经验和教训不过，从我对写作的热情来看，这篇文章可能会拖很久，我还是在这里提一嘴吧也不算太鸽 比如，在用移动端连接pc端的后端的时候，即使使用了跨域，也会无法访问到即使在同一个wifi下，也会有这个问题，因为即使是同一个网络，也可能会分不同网段这涉及内网穿透","tags":["develop","妙手","flutter","ai"],"categories":["作品集"]},{"title":"低配版仿网易云app","path":"/2024/02/01/3wyyapp/","content":"wyyappA new Flutter project. Getting Started一个简陋版的仿网易云音乐app，供学习使用开发实践1.17-2.1 一共十五天，中间休息了三天经历了大大小小四五次重构，原本的代码写的太烂了 出于 要拓展自己技术栈的目的，这个app先告一段落之后需要学一些go后端以及鸿蒙生态,flutter 还是不值得all in不如说，由于本人的性格，我不会all in任何一门技术 网易云接口是适配pc端的，对于android端的适配不是很好，所以有些功能实现起来非常复杂不过的确有app端的首页接口，但是其内部结构过于复杂,尝试分析，明白了大部分接口的含义然而，嵌套起来实在太过复杂,具体请看最后的分析 所以只做了核心功能歌曲类的封装，包括下载、下一首、重新播放等功能下载类的封装、通知类的封装 可以说,封装、整理、以及称得上是舒爽的代码结构是我在这个项目中学到的最有价值的东西 项目截图 下载功能 通过android 的notification实现下载进度的展示 以及播放的控制 搜索 深色模式 歌单广场 批量管理 “分析”以下是对于网易云音乐接口的分析的一角，总的来说对我启发的最重要的点是他们通过后端来控制前端代码的展示结构，这样的代码我第一次见到 初见时候，不禁又对前端的作用心生鄙夷后面尝试复现前端的实现类的时候才发现，这样的组织结构，对于前端来说,是非常不友好的至少对一个未从头参与开发的初级学习者来说是这样的","tags":["本手","android","flutter"],"categories":["作品集"]},{"title":"鸟宿池边树","path":"/2024/01/13/2some/","content":"总的来说，我不是一个爱写文章的人。记起来从写人生第一篇作文开始，我的写作之路就没有遇到过坦途。曾经试着反思原因，大抵是因为一些完美主义倾向。譬如写了上一句，要对下一句的方向内容乃至把字句被字句都要犹豫很久。不过这也是可贵的，古代诗人曾经有过诗句。鸟宿池边树，僧敲月下门。为人性僻耽佳句，语不惊人死不休。想来那些欧阳修、柳宗元之类的大家都曾如此。 就譬如写上一段以及这一段，大抵改了二十次有余。 最近还是在做我名为 ”电梯维保“ 的项目，不过近几日工作少了些枯燥。添加了些百度api定位之类的，由此引出来了种种。 以下是这几日我遇到的一些问题，权当是总结，也是为了以后找起来方便。 1. sourcetree 配置 github SSH原因：在像往常一样用ssh拉取git仓库的时候报了 port：22 timeout错误，故此总结了两篇比较简洁的技术博客 配置ssh ：https://juejin.cn/post/7224017330724175927 修改config（如果没有config则新建）：https://blog.csdn.net/the__future/article/details/130038818 2.百度api1.百度api location定位功能 封装代码以下是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127class GetLocation &#123; static int count = 0; static bool starLocate = false; static double latitude = 0; static double longitude = 0; GetLocation(); static LocationFlutterPlugin myLocPlugin = LocationFlutterPlugin(); static BaiduLocation baiduLocation = BaiduLocation(); static Future&lt;bool&gt; locationInit() async &#123; log(&quot;定位初始化&quot;); /// 动态申请定位权限 if (await requestPermission()) &#123; myLocPlugin.setAgreePrivacy(true); myLocPlugin.getApiKeyCallback(callback: (String result) &#123; String str = result; log(&#x27;鉴权结果：&#x27; + str); &#125;); myLocPlugin.seriesLocationCallback( callback: (BaiduLocation result) async &#123; if (count &gt;= 10) &#123; await myLocPlugin.stopLocation(); &#125; else &#123; if (result.latitude != null &amp;&amp; result.longitude != null) &#123; await myLocPlugin.stopLocation(); longitude = result.longitude!; latitude = result.latitude!; &#125;else&#123; log(&quot;错误码:$&#123;result.errorCode&#125; $&#123;result.errorInfo&#125; $&#123;result.getMap().toString()&#125;&quot;); &#125; &#125; &#125;); Map androidMap = initAndroidOptions().getMap(); Map iosMap = initIOSOptions().getMap(); var _suc = await myLocPlugin.prepareLoc(androidMap, iosMap); return true; &#125; else &#123; return false; &#125; &#125; static BaiduLocationAndroidOption initAndroidOptions() &#123; BaiduLocationAndroidOption options = BaiduLocationAndroidOption( locationMode: BMFLocationMode.hightAccuracy, isNeedAddress: false, isNeedAltitude: false, isNeedLocationPoiList: false, isNeedNewVersionRgc: true, isNeedLocationDescribe: true, openGps: true, locationPurpose: BMFLocationPurpose.sport, coordType: BMFLocationCoordType.bd09ll, scanspan: 0); return options; &#125; static BaiduLocationIOSOption initIOSOptions() &#123; BaiduLocationIOSOption options = BaiduLocationIOSOption( coordType: BMFLocationCoordType.bd09ll, locationTimeout: 10, reGeocodeTimeout: 10, activityType: BMFActivityType.automotiveNavigation, desiredAccuracy: BMFDesiredAccuracy.best, isNeedNewVersionRgc: true, pausesLocationUpdatesAutomatically: false, allowsBackgroundLocationUpdates: true, distanceFilter: 10, ); return options; &#125; static Future&lt;Map&gt; getLocationSingle() async &#123; await myLocPlugin.stopLocation(); longitude = 0; latitude = 0; starLocate = false; count = 0; Map result = &#123;&quot;success&quot;: false&#125;; log(&quot;进入&quot;); while (count &lt; 10) &#123; if (!starLocate) &#123; starLocate = true; bool test=await myLocPlugin.startLocation(); &#125; await Future.delayed(const Duration(seconds: 1)) .then((_) &#123; count++; if (longitude != 0 || latitude != 0) &#123; double tlong = longitude; double tl = latitude; result = &#123;&quot;success&quot;: true, &quot;longitude&quot;: tlong, &quot;latitude&quot;: tl&#125;; starLocate=false; &#125; &#125;); if (!starLocate) &#123; break; &#125; &#125; longitude = 0; latitude = 0; starLocate = false; count = 0; starLocate = false; myLocPlugin.stopLocation(); return result; &#125; static Future&lt;bool&gt; requestPermission() async &#123; if (!(await Permission.location.isLimited || await Permission.location.isRestricted || await Permission.location.isGranted)) &#123; await Permission.location.request(); &#125; if ((await Permission.location.isLimited || await Permission.location.isRestricted || await Permission.location.isGranted)) &#123; return true; &#125; else &#123; Get.defaultDialog(title: &quot;错误&quot;,content: const Text(&quot;无法获取位置信息，请手动设置权限后重启app&quot;)); return false; &#125; &#125;&#125; 这段直接引用了另外一个同学的代码，我自己用 get 插件的GetxController 成功封装过一次，不过现在想想封装逻辑较之不是很清晰。 2.由此引申的so文件在实现了上述的location的封装以及应用之后，想要自己做一个类似于百度地图app，故而尝试调用了百度地图api。 1234567891011121314BMFMapOptions mapOptions = BMFMapOptions( center: BMFCoordinate(39.917215, 116.380341), zoomLevel: 12, mapPadding: BMFEdgeInsets(left: 30, top: 0, right: 30, bottom: 0));Container( height: screenSize.height, width: screenSize.width, child: BMFMapWidget( onBMFMapCreated: (controller) &#123; onBMFMapCreated(controller); &#125;, mapOptions: mapOptions, ), ); 成功按照文档配置好环境以后，出现了地图黑屏的问题（此时并没有退出）。然而在网上一些社区csdn 掘金 stackoverflow，并没有找到解决方案。观察控制台的报错，发现是 缺少了 libgnustl_shared.zip文件。 找了好久找到了下载地址：https://ava3.androidfilehost.com/dl/JjPZ-RTGo8BAooDv19LIJQ/1705286685/24588232905720518/libgnustl_shared.zip? 然而按照网络上的方法配置到项目里后，没有用，故放弃。 以下是so文件的简述以及作用： 12345&quot;.so&quot; 文件是一种共享库（Shared Object Library）文件的后缀名。这种文件格式通常在类Unix操作系统（如Linux）中使用。共享库包含一组预编译的可执行代码和数据，可以被多个程序共享，以提供共享的功能和资源。这些文件通常包含编译后的二进制代码，可以被动态链接到程序中，而不是静态地嵌入在每个程序中。这样做有助于减小程序文件的大小，同时允许多个程序共享相同的代码库，提高系统的效率。在Linux系统中，共享库文件通常存储在 &quot;/lib&quot; 或 &quot;/usr/lib&quot; 目录下，而应用程序通过动态链接器在运行时加载这些库。这种动态链接的方式有助于减少内存占用，同时简化程序的维护和更新。 3.网易云api对接百度api失败之后有点烦，于是… 涉及到的知识点：docker 、serveless 、nodejs跨域 感谢开源项目： ​ 1.github地址：&#103;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#x6d;:Binaryify&#x2F;NeteaseCloudMusicApi.git ​ 2.官方网站 :https://docs.neteasecloudmusicapi.binaryify.com/ 算是一个总结，也算是一个分享： 1234567891.克隆仓库并运行项目git clone git@github.com:Binaryify/NeteaseCloudMusicApi.gitcd NeteaseCloudMusicApinpm installnode app.js//之后可以在默认3000端口访问到set PORT=4000 &amp;&amp; node app.js 1.docker 部署docker 是在我大一下学期接触到的，当时一并学了vim，堪称利器。然而docker对当时的我相当于降维打击，很多概念都无法理解。现在则一学就会，验证了认识的螺旋上升性。 12345$ git clone https://github.com/Binaryify/NeteaseCloudMusicApi &amp;&amp; cd NeteaseCloudMusicApi$ sudo docker build . -t netease-music-api$ sudo docker run -d -p 3000:3000 netease-music-api 可视化版本的，在docker应用里的”dev enviroments“里添加任务夹即可 不过部署之后在客户端请求会遇到跨域问题，这点我们之后再说 2. 跨域问题因为本人是打算做一个flutter的android项目的，所以会遇到跨域问题 以下是我在掘金上搜索到的node js解决代码， 不过我在本地运行之后并没有解决跨域，权且当一个记录，量变引起质变，或许早晚会用到 123456789101112131415161718192021222324252627282930313233343536373839404142const http = require(&#x27;http&#x27;);// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123; // 代理服务器，直接和浏览器直接交互，也需要设置：CORS 的首部字段 response.writeHead(200, &#123; &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;, // 设置 optins 方法允许所有服务器访问 &#x27;Access-Control-Allow-Methods&#x27;: &#x27;*&#x27;, &#x27;Access-Control-Allow-Headers&#x27;: &#x27;Content-Type&#x27;, &#125;); // 第二步：将请求转发给服务器 const proxyRequest = http.request(&#123; host: &#x27;127.0.0.1&#x27;, port: 4000, url: &#x27;/&#x27;, method: request.method, headers: request.headers &#125;, (serverResponse) =&gt; &#123; // 第三步：收到服务器的响应 var body = &#x27;&#x27;; serverResponse.on(&#x27;data&#x27;, (chunk) =&gt; &#123; body += chunk; &#125;); serverResponse.on(&#x27;end&#x27;, () =&gt; &#123; console.log(&#x27;The data is &#x27; + body ); // 第四步：将响应结果转发给浏览器 response.end(body); &#125;) &#125;).end();&#125;);server.listen(3000, () =&gt; &#123; console.log(&#x27;The proxyServer is running at http://localhost:3000&#x27;);&#125;); 3.serveless部署网址： https://console.cloud.tencent.com/sls 以下是步骤： fork 此项目 在腾讯云serverless应用管理页面( https://console.cloud.tencent.com/sls ),点击新建应用 顶部创建方式选择 Web 应用 选择 Express框架,点击底部下一步按钮 输入应用名,上传方式选择代码仓库,进行GitHub授权(如已授权可跳过这一步),代码仓库选择刚刚fork的项目 启动文件填入: 123#!/bin/bashexport PORT=9000/var/lang/node16/bin/node app.js 点击完成,等待部署完成,点击资源列表的 API网关 里的 URL,正常情况会打开文档地址,点击文档例子可查看接口调用效果 在serveless部署之后，跨域问题解决了。","tags":["android","flutter","俗手"]},{"title":"一个奇怪的bug解决（误）经历","path":"/2023/12/03/1android_local_notification/","content":"一个奇怪的实现经历背景事情是这样的:2023年十一月的一个晚上，本人正陷于就业和找实习的泥潭中，焦虑不已。于是，遂观于某位学长的前端就业讲座之中，讲到最后，学长提到了“开源项目”，大惊。原因是本人上学期一直想投入到某个开源项目里，奈何实力不允许，便搁置。搁置也罢，罢不了的是，由于太忙，竟然完全忘了“开源项目”这个概念。于是便突发奇想：自己开源一个项目。做一个日期闹钟app，不仅在对应的时间提醒，还可以在对应的一段时间一直浮现在桌面上 那么这时候就有人要问了：为什么不在应用商店找一个呢？原因有二：1.外面的app太繁杂 2.我愿意 实现:系统通知功能几经翻找，发现flutter官方并没有提供闹钟的插件，在第三方库中找到了一个名为：flutter location notice的插件。 事实上，几乎推进的很顺利，直到我发现了一个奇怪的属性。 1234567891011 const AndroidNotificationDetails androidNotificationDetails = AndroidNotificationDetails(&#x27;your channel id&#x27;, &#x27;your channel name&#x27;, channelDescription: &#x27;your channel description&#x27;, importance: Importance.max, priority: Priority.high, ticker: &#x27;ticker&#x27;);const NotificationDetails notificationDetails = NotificationDetails(android: androidNotificationDetails);await flutterLocalNotificationsPlugin.show( 0, &#x27;plain title&#x27;, &#x27;plain body&#x27;, notificationDetails, payload: &#x27;item x&#x27;); 什么是channel id!？什么是channel name!？ 第一步:联想我之前做过一个腾讯云储存、腾讯云聊天的项目，里面有一个id的概念，那么这个channel id的获取方式是不是类似呢？思考思考思考思考思考，发现应该不是，这个channel id是一个字符串我的云储存云聊天，是基于腾讯云服务器的，理应要一个id但是提醒功能，只是基于本地的，理应不需要一个id 第二步:stackoverflow这一步上，很快，我找到了一篇类似的问题 flutter local notification: what’s the channel id?喜悦之情溢于言表，然而细细看去这篇问题的答案对于我来说就是驴唇不对马嘴： 我要问的是： channel id是什么？怎么获取？而不是：channel id 有什么用（悲伤） 一秒回到解放前 第三步: developer究其技术原因，不过是利用了android method channel，封装了一些方法实现功能还是要依靠原生android的api 既然如此，那么我就去看看android developer的文档吧! 创建和管理通知渠道 通知渠道是用户可在 Android 系统的通知设置中看到的通知类别。您可以为您的应用创建多个通知渠道。例如，您可以为您的应用的每个通知类型创建一个通知渠道。您可以在每个渠道上设置通知行为，例如您可以在某些渠道上启用或禁用通知提示、在其他渠道上显示通知标记、或在其他渠道上启用或禁用通知徽标。 所以，通知渠道应该指的是：弹窗、声音、震动等等但是，文档里面并没有提到channel id的获取方式 第四步:从头再捋一遍既然哪里都没有提到channel id的获取方式，那么我就从头再完成一遍插件的实现吧！ 第一步，初始化 12345678FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin();const AndroidInitializationSettings initializationSettingsAndroid = AndroidInitializationSettings(&#x27;app_icon&#x27;);final InitializationSettings initializationSettings = InitializationSettings( android: initializationSettingsAndroid);await flutterLocalNotificationsPlugin.initialize(initializationSettings, onDidReceiveNotificationResponse: onDidReceiveNotificationResponse); 第二步，创建通知渠道 123456const AndroidNotificationDetails androidPlatformChannelSpecifics = AndroidNotificationDetails(&#x27;your channel id&#x27;, &#x27;your channel name&#x27;, &#x27;your channel description&#x27;, importance: Importance.max, priority: Priority.high, showWhen: false); 在这时,我凭借一种摆烂直觉，将channel id改为了一个随机字符串，然后运行，发现，没有任何问题，通知竟然也正常弹出了 什么是channel id!？什么是channel name!？","tags":["android","flutter"]},{"path":"/test.js","content":"class Person { static name = 123 }"},{"path":"/css/custom-font.css","content":"@font-face { font-family: 'LXGW WenKai Screen'; src: url('../fonts/LXGWWenKaiGBScreen.ttf') format('truetype'); font-weight: 400; font-style: normal; }"}]